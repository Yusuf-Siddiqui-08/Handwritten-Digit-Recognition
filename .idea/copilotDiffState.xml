<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DigitRecognizer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DigitRecognizer.py" />
              <option name="originalContent" value="import numpy as np&#10;import json&#10;import os&#10;&#10;&#10;class DigitRecognizer:&#10;    &quot;&quot;&quot;&#10;    A class that handles digit recognition, pattern matching, and learning functionality.&#10;    This class is separate from the GUI and focuses purely on the recognition logic.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Grid settings for pattern matching&#10;        self.grid_size = 14  # 14x14 grid for pattern matching&#10;&#10;        # File for storing learned patterns&#10;        self.learned_patterns_file = &quot;learned_patterns.json&quot;&#10;&#10;        # Initialize digit patterns&#10;        self.digit_patterns = self.create_digit_patterns()&#10;&#10;        # Load learned patterns&#10;        self.learned_patterns = self.load_learned_patterns()&#10;&#10;    def preprocess_drawing(self, array):&#10;        &quot;&quot;&quot;Preprocess the drawing array to center and scale it appropriately&quot;&quot;&quot;&#10;        # Find the bounding box of the drawn pixels&#10;        rows, cols = np.where(array &gt; 0)&#10;&#10;        if len(rows) == 0:&#10;            return array  # Empty array&#10;&#10;        min_row, max_row = rows.min(), rows.max()&#10;        min_col, max_col = cols.min(), cols.max()&#10;&#10;        # Extract the drawing within its bounding box&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate if the drawing is too small relative to canvas&#10;        canvas_utilization = (drawing_height * drawing_width) / (self.grid_size * self.grid_size)&#10;&#10;        # If drawing uses less than 25% of the canvas, apply scaling and centering&#10;        if canvas_utilization &lt; 0.25 or drawing_height &lt; self.grid_size * 0.5 or drawing_width &lt; self.grid_size * 0.5:&#10;            return self.center_and_scale_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # If drawing is reasonably sized, center it if it's off-center&#10;        center_row = (min_row + max_row) / 2&#10;        center_col = (min_col + max_col) / 2&#10;        canvas_center = self.grid_size / 2&#10;&#10;        # If drawing is significantly off-center, center it&#10;        if abs(center_row - canvas_center) &gt; 2 or abs(center_col - canvas_center) &gt; 2:&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        return array&#10;&#10;    def center_and_scale_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center and scale up a small drawing to better fill the canvas&quot;&quot;&quot;&#10;        # Extract the drawing&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate scaling factor to make drawing fill more of the canvas&#10;        # Target the drawing to use about 70% of canvas size&#10;        target_size = int(self.grid_size * 0.7)&#10;        scale_factor = min(target_size / drawing_height, target_size / drawing_width)&#10;        scale_factor = min(scale_factor, 3.0)  # Cap scaling to prevent artifacts&#10;&#10;        if scale_factor &lt;= 1.0:&#10;            # If no scaling needed, center&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # Create new array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Calculate new dimensions&#10;        new_height = int(drawing_height * scale_factor)&#10;        new_width = int(drawing_width * scale_factor)&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - new_height) // 2)&#10;        start_col = max(0, (self.grid_size - new_width) // 2)&#10;&#10;        # Scale the drawing using nearest neighbor interpolation&#10;        for i in range(new_height):&#10;            for j in range(new_width):&#10;                orig_row = min_row + int(i / scale_factor)&#10;                orig_col = min_col + int(j / scale_factor)&#10;&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size and&#10;                    orig_row &lt;= max_row and orig_col &lt;= max_col):&#10;                    new_array[start_row + i, start_col + j] = array[orig_row, orig_col]&#10;&#10;        return new_array&#10;&#10;    def center_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center the drawing without scaling&quot;&quot;&quot;&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - drawing_height) // 2)&#10;        start_col = max(0, (self.grid_size - drawing_width) // 2)&#10;&#10;        # Create new centered array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Copy the drawing to center position&#10;        for i in range(drawing_height):&#10;            for j in range(drawing_width):&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size):&#10;                    new_array[start_row + i, start_col + j] = array[min_row + i, min_col + j]&#10;&#10;        return new_array&#10;&#10;    def create_digit_patterns(self):&#10;        &quot;&quot;&quot;Create predefined patterns for digits 0-9&quot;&quot;&quot;&#10;        patterns = {}&#10;&#10;        # Digit 0 patterns&#10;        patterns[0] = [&#10;            # Pattern 1: Oval shape&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 1 patterns&#10;        patterns[1] = [&#10;            # Pattern 1: Straight line&#10;            np.array([&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ]),&#10;            # Pattern 2: Simple vertical line&#10;            np.array([&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 2 patterns&#10;        patterns[2] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,1,1,1,1,0,0,0],&#10;                [0,0,0,0,0,1,1,1,1,0,0,0,0,0],&#10;                [0,0,0,1,1,1,1,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 3 patterns&#10;        patterns[3] = [&#10;            np.array([&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 4 patterns&#10;        patterns[4] = [&#10;            np.array([&#10;                [0,0,0,0,0,0,0,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,1,1,1,0,1,1,0,0,0,0],&#10;                [0,0,0,1,1,1,0,0,1,1,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,1,1,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,1,1,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,1,1,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 5 patterns&#10;        patterns[5] = [&#10;            np.array([&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 6 patterns&#10;        patterns[6] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,0,1,1,1,1,1,1,1,1,1,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 7 patterns&#10;        patterns[7] = [&#10;            # Pattern 1: Simple 7&#10;            np.array([&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,1,0,0,0],&#10;                [0,0,0,0,0,0,0,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,0,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,0,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ]),&#10;            # Pattern 2: 7 with cross&#10;            np.array([&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,1,0,0,0],&#10;                [0,0,0,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,0,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,0,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 8 patterns&#10;        patterns[8] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 9 patterns&#10;        patterns[9] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        return patterns&#10;&#10;    def calculate_similarity(self, drawn_array, pattern):&#10;        &quot;&quot;&quot;Calculate similarity between drawn array and pattern using multiple metrics&quot;&quot;&quot;&#10;        # Normalize both arrays to ensure they're binary&#10;        drawn_binary = (drawn_array &gt; 0).astype(int)&#10;        pattern_binary = (pattern &gt; 0).astype(int)&#10;&#10;        # Calculate intersection over union (IoU)&#10;        intersection = np.sum(drawn_binary &amp; pattern_binary)&#10;        union = np.sum(drawn_binary | pattern_binary)&#10;&#10;        if union == 0:&#10;            return 0.0&#10;&#10;        iou = intersection / union&#10;&#10;        # Calculate coverage (how much of the pattern is covered)&#10;        pattern_pixels = np.sum(pattern_binary)&#10;        if pattern_pixels == 0:&#10;            return 0.0&#10;        coverage = intersection / pattern_pixels&#10;&#10;        # Calculate precision (how much of the drawing matches the pattern)&#10;        drawn_pixels = np.sum(drawn_binary)&#10;        if drawn_pixels == 0:&#10;            return 0.0&#10;        precision = intersection / drawn_pixels&#10;&#10;        # Weighted combination of metrics&#10;        similarity = 0.4 * iou + 0.3 * coverage + 0.3 * precision&#10;&#10;        return similarity&#10;&#10;    def predict_digit(self, drawn_array):&#10;        &quot;&quot;&quot;&#10;        Predict the digit based on the drawing array.&#10;        Returns a tuple of (predicted_digit, confidence, all_similarities)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Preprocess the drawing&#10;            processed_array = self.preprocess_drawing(drawn_array)&#10;&#10;            best_digit = None&#10;            best_similarity = 0.0&#10;            similarities = {}&#10;&#10;            # Compare with all patterns (both predefined and learned)&#10;            for digit in range(10):&#10;                max_similarity_for_digit = 0.0&#10;&#10;                # Check predefined patterns&#10;                if digit in self.digit_patterns:&#10;                    for pattern in self.digit_patterns[digit]:&#10;                        similarity = self.calculate_similarity(processed_array, pattern)&#10;                        max_similarity_for_digit = max(max_similarity_for_digit, similarity)&#10;&#10;                # Check learned patterns and give them higher weight&#10;                digit_str = str(digit)&#10;                if digit_str in self.learned_patterns:&#10;                    for pattern_data in self.learned_patterns[digit_str]:&#10;                        try:&#10;                            learned_pattern = np.array(pattern_data['pattern'])&#10;                            learned_similarity = self.calculate_similarity(processed_array, learned_pattern)&#10;                            # Boost learned pattern similarity based on confidence and feedback&#10;                            confidence_boost = 1.0 + (pattern_data.get('confidence', 1.0) * 0.2)&#10;                            feedback_boost = 1.0 + (pattern_data.get('feedback_count', 1) * 0.1)&#10;                            learned_similarity *= confidence_boost * feedback_boost&#10;                            max_similarity_for_digit = max(max_similarity_for_digit, learned_similarity)&#10;                        except (ValueError, KeyError) as e:&#10;                            print(f&quot;Error processing learned pattern for digit {digit}: {e}&quot;)&#10;                            continue&#10;&#10;                similarities[digit] = max_similarity_for_digit&#10;&#10;                if max_similarity_for_digit &gt; best_similarity:&#10;                    best_similarity = max_similarity_for_digit&#10;                    best_digit = digit&#10;&#10;            return best_digit, best_similarity, similarities&#10;&#10;        except Exception as e:&#10;            print(f&quot;Prediction error: {e}&quot;)&#10;            return None, 0.0, {}&#10;&#10;    def add_positive_feedback(self, drawn_array, predicted_digit):&#10;        &quot;&quot;&quot;Add a pattern as a positive example for the predicted digit&quot;&quot;&quot;&#10;        try:&#10;            digit = str(predicted_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit not in self.learned_patterns:&#10;                self.learned_patterns[digit] = []&#10;&#10;            # Add the current drawing as a learned pattern&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1&#10;            }&#10;&#10;            self.learned_patterns[digit].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Positive feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def add_negative_feedback(self, drawn_array, predicted_digit, correct_digit):&#10;        &quot;&quot;&quot;Add a pattern as a correction from predicted_digit to correct_digit&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(correct_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit_str not in self.learned_patterns:&#10;                self.learned_patterns[digit_str] = []&#10;&#10;            # Add the current drawing as a learned pattern with the correct label&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1,&#10;                'corrected_from': predicted_digit&#10;            }&#10;&#10;            self.learned_patterns[digit_str].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Negative feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def remove_last_pattern(self, digit):&#10;        &quot;&quot;&quot;Remove the last pattern added for a digit (used for undo)&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(digit)&#10;            if digit_str in self.learned_patterns and len(self.learned_patterns[digit_str]) &gt; 0:&#10;                self.learned_patterns[digit_str].pop()&#10;&#10;                # If this was the only pattern for this digit, remove the digit entirely&#10;                if len(self.learned_patterns[digit_str]) == 0:&#10;                    del self.learned_patterns[digit_str]&#10;&#10;                return True&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Remove pattern error: {e}&quot;)&#10;            return False&#10;&#10;    def load_learned_patterns(self):&#10;        &quot;&quot;&quot;Load learned patterns from file with error handling&quot;&quot;&quot;&#10;        try:&#10;            if os.path.exists(self.learned_patterns_file):&#10;                with open(self.learned_patterns_file, 'r') as f:&#10;                    data = json.load(f)&#10;                    # Validate the loaded data&#10;                    if isinstance(data, dict):&#10;                        # Convert patterns back to numpy arrays for processing&#10;                        for digit, patterns in data.items():&#10;                            if isinstance(patterns, list):&#10;                                for pattern_data in patterns:&#10;                                    if isinstance(pattern_data, dict) and 'pattern' in pattern_data:&#10;                                        # Pattern data is valid&#10;                                        continue&#10;                                    else:&#10;                                        print(f&quot;Invalid pattern data for digit {digit}&quot;)&#10;                        return data&#10;                    else:&#10;                        print(&quot;Invalid learned patterns file format&quot;)&#10;                        return {}&#10;            else:&#10;                print(&quot;No learned patterns file found, starting fresh&quot;)&#10;                return {}&#10;        except (json.JSONDecodeError, IOError) as e:&#10;            print(f&quot;Error loading learned patterns: {e}&quot;)&#10;            # Try to load backup if available&#10;            backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;            if os.path.exists(backup_file):&#10;                try:&#10;                    with open(backup_file, 'r') as f:&#10;                        print(&quot;Loading from backup file&quot;)&#10;                        return json.load(f)&#10;                except:&#10;                    print(&quot;Backup file also corrupted&quot;)&#10;            return {}&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error loading patterns: {e}&quot;)&#10;            return {}&#10;&#10;    def save_learned_patterns(self):&#10;        &quot;&quot;&quot;Save learned patterns to file with backup and error handling&quot;&quot;&quot;&#10;        try:&#10;            # Create backup of existing file&#10;            if os.path.exists(self.learned_patterns_file):&#10;                backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;                try:&#10;                    import shutil&#10;                    shutil.copy2(self.learned_patterns_file, backup_file)&#10;                except Exception as backup_error:&#10;                    print(f&quot;Warning: Could not create backup: {backup_error}&quot;)&#10;&#10;            # Save current patterns with custom formatting&#10;            with open(self.learned_patterns_file, 'w') as f:&#10;                self._write_formatted_patterns(f, self.learned_patterns)&#10;&#10;            print(f&quot;Learned patterns saved successfully to {self.learned_patterns_file}&quot;)&#10;            return True&#10;&#10;        except (IOError, json.JSONEncodeError) as e:&#10;            print(f&quot;Failed to save learned patterns: {e}&quot;)&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error saving patterns: {e}&quot;)&#10;            return False&#10;&#10;    def _write_formatted_patterns(self, file, patterns_dict):&#10;        &quot;&quot;&quot;Write patterns to file with readable array formatting&quot;&quot;&quot;&#10;        file.write(&quot;{\n&quot;)&#10;&#10;        digit_keys = sorted(patterns_dict.keys(), key=lambda x: int(x))&#10;&#10;        for i, digit in enumerate(digit_keys):&#10;            patterns_list = patterns_dict[digit]&#10;            file.write(f'  &quot;{digit}&quot;: [\n')&#10;&#10;            for j, pattern_data in enumerate(patterns_list):&#10;                file.write(&quot;    {\n&quot;)&#10;&#10;                # Write non-pattern fields first&#10;                for key, value in pattern_data.items():&#10;                    if key != 'pattern':&#10;                        if isinstance(value, str):&#10;                            file.write(f'      &quot;{key}&quot;: &quot;{value}&quot;,\n')&#10;                        else:&#10;                            file.write(f'      &quot;{key}&quot;: {value},\n')&#10;&#10;                # Write pattern array with grid formatting&#10;                file.write('      &quot;pattern&quot;: [\n')&#10;                pattern_array = pattern_data['pattern']&#10;&#10;                for row_idx, row in enumerate(pattern_array):&#10;                    file.write(&quot;        [&quot;)&#10;                    row_str = &quot;,&quot;.join(str(val) for val in row)&#10;                    file.write(row_str)&#10;                    if row_idx &lt; len(pattern_array) - 1:&#10;                        file.write(&quot;],\n&quot;)&#10;                    else:&#10;                        file.write(&quot;]\n&quot;)&#10;&#10;                file.write(&quot;      ]\n&quot;)&#10;&#10;                if j &lt; len(patterns_list) - 1:&#10;                    file.write(&quot;    },\n&quot;)&#10;                else:&#10;                    file.write(&quot;    }\n&quot;)&#10;&#10;            if i &lt; len(digit_keys) - 1:&#10;                file.write(&quot;  ],\n&quot;)&#10;            else:&#10;                file.write(&quot;  ]\n&quot;)&#10;&#10;        file.write(&quot;}\n&quot;)&#10;&#10;    def get_pattern_count(self, digit=None):&#10;        &quot;&quot;&quot;Get the count of learned patterns for a digit or all digits&quot;&quot;&quot;&#10;        if digit is not None:&#10;            digit_str = str(digit)&#10;            return len(self.learned_patterns.get(digit_str, []))&#10;        else:&#10;            total = 0&#10;            for patterns in self.learned_patterns.values():&#10;                total += len(patterns)&#10;            return total&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import json&#10;import os&#10;&#10;&#10;class DigitRecognizer:&#10;    &quot;&quot;&quot;&#10;    A class that handles digit recognition, pattern matching, and learning functionality.&#10;    This class is separate from the GUI and focuses purely on the recognition logic.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Grid settings for pattern matching&#10;        self.grid_size = 28  # 28x28 grid for pattern matching&#10;&#10;        # File for storing learned patterns&#10;        self.learned_patterns_file = &quot;learned_patterns.json&quot;&#10;&#10;        # Initialize digit patterns&#10;        self.digit_patterns = self.create_digit_patterns()&#10;&#10;        # Load learned patterns&#10;        self.learned_patterns = self.load_learned_patterns()&#10;&#10;    def preprocess_drawing(self, array):&#10;        &quot;&quot;&quot;Preprocess the drawing array to center and scale it appropriately&quot;&quot;&quot;&#10;        # Find the bounding box of the drawn pixels&#10;        rows, cols = np.where(array &gt; 0)&#10;&#10;        if len(rows) == 0:&#10;            return array  # Empty array&#10;&#10;        min_row, max_row = rows.min(), rows.max()&#10;        min_col, max_col = cols.min(), cols.max()&#10;&#10;        # Extract the drawing within its bounding box&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate if the drawing is too small relative to canvas&#10;        canvas_utilization = (drawing_height * drawing_width) / (self.grid_size * self.grid_size)&#10;&#10;        # If drawing uses less than 25% of the canvas, apply scaling and centering&#10;        if canvas_utilization &lt; 0.25 or drawing_height &lt; self.grid_size * 0.5 or drawing_width &lt; self.grid_size * 0.5:&#10;            return self.center_and_scale_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # If drawing is reasonably sized, center it if it's off-center&#10;        center_row = (min_row + max_row) / 2&#10;        center_col = (min_col + max_col) / 2&#10;        canvas_center = self.grid_size / 2&#10;&#10;        # If drawing is significantly off-center, center it&#10;        if abs(center_row - canvas_center) &gt; 2 or abs(center_col - canvas_center) &gt; 2:&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        return array&#10;&#10;    def center_and_scale_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center and scale up a small drawing to better fill the canvas&quot;&quot;&quot;&#10;        # Extract the drawing&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate scaling factor to make drawing fill more of the canvas&#10;        # Target the drawing to use about 70% of canvas size&#10;        target_size = int(self.grid_size * 0.7)&#10;        scale_factor = min(target_size / drawing_height, target_size / drawing_width)&#10;        scale_factor = min(scale_factor, 3.0)  # Cap scaling to prevent artifacts&#10;&#10;        if scale_factor &lt;= 1.0:&#10;            # If no scaling needed, center&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # Create new array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Calculate new dimensions&#10;        new_height = int(drawing_height * scale_factor)&#10;        new_width = int(drawing_width * scale_factor)&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - new_height) // 2)&#10;        start_col = max(0, (self.grid_size - new_width) // 2)&#10;&#10;        # Scale the drawing using nearest neighbor interpolation&#10;        for i in range(new_height):&#10;            for j in range(new_width):&#10;                orig_row = min_row + int(i / scale_factor)&#10;                orig_col = min_col + int(j / scale_factor)&#10;&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size and&#10;                    orig_row &lt;= max_row and orig_col &lt;= max_col):&#10;                    new_array[start_row + i, start_col + j] = array[orig_row, orig_col]&#10;&#10;        return new_array&#10;&#10;    def center_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center the drawing without scaling&quot;&quot;&quot;&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - drawing_height) // 2)&#10;        start_col = max(0, (self.grid_size - drawing_width) // 2)&#10;&#10;        # Create new centered array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Copy the drawing to center position&#10;        for i in range(drawing_height):&#10;            for j in range(drawing_width):&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size):&#10;                    new_array[start_row + i, start_col + j] = array[min_row + i, min_col + j]&#10;&#10;        return new_array&#10;&#10;    def create_digit_patterns(self):&#10;        &quot;&quot;&quot;Create predefined patterns for digits 0-9&quot;&quot;&quot;&#10;        patterns = {}&#10;&#10;        # Digit 0 patterns&#10;        patterns[0] = [&#10;            # Pattern 1: Oval shape&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 1 patterns&#10;        patterns[1] = [&#10;            # Pattern 1: Straight line&#10;            np.array([&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ]),&#10;            # Pattern 2: Simple vertical line&#10;            np.array([&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 2 patterns&#10;        patterns[2] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,1,1,1,1,0,0,0],&#10;                [0,0,0,0,0,1,1,1,1,0,0,0,0,0],&#10;                [0,0,0,1,1,1,1,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 3 patterns&#10;        patterns[3] = [&#10;            np.array([&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 4 patterns&#10;        patterns[4] = [&#10;            np.array([&#10;                [0,0,0,0,0,0,0,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,1,1,1,0,1,1,0,0,0,0],&#10;                [0,0,0,1,1,1,0,0,1,1,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,1,1,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,1,1,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,1,1,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 5 patterns&#10;        patterns[5] = [&#10;            np.array([&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 6 patterns&#10;        patterns[6] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,0,1,1,1,1,1,1,1,1,1,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 7 patterns&#10;        patterns[7] = [&#10;            # Pattern 1: Simple 7&#10;            np.array([&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,1,0,0,0],&#10;                [0,0,0,0,0,0,0,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,0,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,0,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ]),&#10;            # Pattern 2: 7 with cross&#10;            np.array([&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,1,0,0,0],&#10;                [0,0,0,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,0,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,0,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 8 patterns&#10;        patterns[8] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 9 patterns&#10;        patterns[9] = [&#10;            np.array([&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        return patterns&#10;&#10;    def calculate_similarity(self, drawn_array, pattern):&#10;        &quot;&quot;&quot;Calculate similarity between drawn array and pattern using multiple metrics&quot;&quot;&quot;&#10;        # Normalize both arrays to ensure they're binary&#10;        drawn_binary = (drawn_array &gt; 0).astype(int)&#10;        pattern_binary = (pattern &gt; 0).astype(int)&#10;&#10;        # Calculate intersection over union (IoU)&#10;        intersection = np.sum(drawn_binary &amp; pattern_binary)&#10;        union = np.sum(drawn_binary | pattern_binary)&#10;&#10;        if union == 0:&#10;            return 0.0&#10;&#10;        iou = intersection / union&#10;&#10;        # Calculate coverage (how much of the pattern is covered)&#10;        pattern_pixels = np.sum(pattern_binary)&#10;        if pattern_pixels == 0:&#10;            return 0.0&#10;        coverage = intersection / pattern_pixels&#10;&#10;        # Calculate precision (how much of the drawing matches the pattern)&#10;        drawn_pixels = np.sum(drawn_binary)&#10;        if drawn_pixels == 0:&#10;            return 0.0&#10;        precision = intersection / drawn_pixels&#10;&#10;        # Weighted combination of metrics&#10;        similarity = 0.4 * iou + 0.3 * coverage + 0.3 * precision&#10;&#10;        return similarity&#10;&#10;    def predict_digit(self, drawn_array):&#10;        &quot;&quot;&quot;&#10;        Predict the digit based on the drawing array.&#10;        Returns a tuple of (predicted_digit, confidence, all_similarities)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Preprocess the drawing&#10;            processed_array = self.preprocess_drawing(drawn_array)&#10;&#10;            best_digit = None&#10;            best_similarity = 0.0&#10;            similarities = {}&#10;&#10;            # Compare with all patterns (both predefined and learned)&#10;            for digit in range(10):&#10;                max_similarity_for_digit = 0.0&#10;&#10;                # Check predefined patterns&#10;                if digit in self.digit_patterns:&#10;                    for pattern in self.digit_patterns[digit]:&#10;                        similarity = self.calculate_similarity(processed_array, pattern)&#10;                        max_similarity_for_digit = max(max_similarity_for_digit, similarity)&#10;&#10;                # Check learned patterns and give them higher weight&#10;                digit_str = str(digit)&#10;                if digit_str in self.learned_patterns:&#10;                    for pattern_data in self.learned_patterns[digit_str]:&#10;                        try:&#10;                            learned_pattern = np.array(pattern_data['pattern'])&#10;                            learned_similarity = self.calculate_similarity(processed_array, learned_pattern)&#10;                            # Boost learned pattern similarity based on confidence and feedback&#10;                            confidence_boost = 1.0 + (pattern_data.get('confidence', 1.0) * 0.2)&#10;                            feedback_boost = 1.0 + (pattern_data.get('feedback_count', 1) * 0.1)&#10;                            learned_similarity *= confidence_boost * feedback_boost&#10;                            max_similarity_for_digit = max(max_similarity_for_digit, learned_similarity)&#10;                        except (ValueError, KeyError) as e:&#10;                            print(f&quot;Error processing learned pattern for digit {digit}: {e}&quot;)&#10;                            continue&#10;&#10;                similarities[digit] = max_similarity_for_digit&#10;&#10;                if max_similarity_for_digit &gt; best_similarity:&#10;                    best_similarity = max_similarity_for_digit&#10;                    best_digit = digit&#10;&#10;            return best_digit, best_similarity, similarities&#10;&#10;        except Exception as e:&#10;            print(f&quot;Prediction error: {e}&quot;)&#10;            return None, 0.0, {}&#10;&#10;    def add_positive_feedback(self, drawn_array, predicted_digit):&#10;        &quot;&quot;&quot;Add a pattern as a positive example for the predicted digit&quot;&quot;&quot;&#10;        try:&#10;            digit = str(predicted_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit not in self.learned_patterns:&#10;                self.learned_patterns[digit] = []&#10;&#10;            # Add the current drawing as a learned pattern&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1&#10;            }&#10;&#10;            self.learned_patterns[digit].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Positive feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def add_negative_feedback(self, drawn_array, predicted_digit, correct_digit):&#10;        &quot;&quot;&quot;Add a pattern as a correction from predicted_digit to correct_digit&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(correct_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit_str not in self.learned_patterns:&#10;                self.learned_patterns[digit_str] = []&#10;&#10;            # Add the current drawing as a learned pattern with the correct label&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1,&#10;                'corrected_from': predicted_digit&#10;            }&#10;&#10;            self.learned_patterns[digit_str].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Negative feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def remove_last_pattern(self, digit):&#10;        &quot;&quot;&quot;Remove the last pattern added for a digit (used for undo)&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(digit)&#10;            if digit_str in self.learned_patterns and len(self.learned_patterns[digit_str]) &gt; 0:&#10;                self.learned_patterns[digit_str].pop()&#10;&#10;                # If this was the only pattern for this digit, remove the digit entirely&#10;                if len(self.learned_patterns[digit_str]) == 0:&#10;                    del self.learned_patterns[digit_str]&#10;&#10;                return True&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Remove pattern error: {e}&quot;)&#10;            return False&#10;&#10;    def load_learned_patterns(self):&#10;        &quot;&quot;&quot;Load learned patterns from file with error handling&quot;&quot;&quot;&#10;        try:&#10;            if os.path.exists(self.learned_patterns_file):&#10;                with open(self.learned_patterns_file, 'r') as f:&#10;                    data = json.load(f)&#10;                    # Validate the loaded data&#10;                    if isinstance(data, dict):&#10;                        # Convert patterns back to numpy arrays for processing&#10;                        for digit, patterns in data.items():&#10;                            if isinstance(patterns, list):&#10;                                for pattern_data in patterns:&#10;                                    if isinstance(pattern_data, dict) and 'pattern' in pattern_data:&#10;                                        # Pattern data is valid&#10;                                        continue&#10;                                    else:&#10;                                        print(f&quot;Invalid pattern data for digit {digit}&quot;)&#10;                        return data&#10;                    else:&#10;                        print(&quot;Invalid learned patterns file format&quot;)&#10;                        return {}&#10;            else:&#10;                print(&quot;No learned patterns file found, starting fresh&quot;)&#10;                return {}&#10;        except (json.JSONDecodeError, IOError) as e:&#10;            print(f&quot;Error loading learned patterns: {e}&quot;)&#10;            # Try to load backup if available&#10;            backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;            if os.path.exists(backup_file):&#10;                try:&#10;                    with open(backup_file, 'r') as f:&#10;                        print(&quot;Loading from backup file&quot;)&#10;                        return json.load(f)&#10;                except:&#10;                    print(&quot;Backup file also corrupted&quot;)&#10;            return {}&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error loading patterns: {e}&quot;)&#10;            return {}&#10;&#10;    def save_learned_patterns(self):&#10;        &quot;&quot;&quot;Save learned patterns to file with backup and error handling&quot;&quot;&quot;&#10;        try:&#10;            # Create backup of existing file&#10;            if os.path.exists(self.learned_patterns_file):&#10;                backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;                try:&#10;                    import shutil&#10;                    shutil.copy2(self.learned_patterns_file, backup_file)&#10;                except Exception as backup_error:&#10;                    print(f&quot;Warning: Could not create backup: {backup_error}&quot;)&#10;&#10;            # Save current patterns with custom formatting&#10;            with open(self.learned_patterns_file, 'w') as f:&#10;                self._write_formatted_patterns(f, self.learned_patterns)&#10;&#10;            print(f&quot;Learned patterns saved successfully to {self.learned_patterns_file}&quot;)&#10;            return True&#10;&#10;        except (IOError, json.JSONEncodeError) as e:&#10;            print(f&quot;Failed to save learned patterns: {e}&quot;)&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error saving patterns: {e}&quot;)&#10;            return False&#10;&#10;    def _write_formatted_patterns(self, file, patterns_dict):&#10;        &quot;&quot;&quot;Write patterns to file with readable array formatting&quot;&quot;&quot;&#10;        file.write(&quot;{\n&quot;)&#10;&#10;        digit_keys = sorted(patterns_dict.keys(), key=lambda x: int(x))&#10;&#10;        for i, digit in enumerate(digit_keys):&#10;            patterns_list = patterns_dict[digit]&#10;            file.write(f'  &quot;{digit}&quot;: [\n')&#10;&#10;            for j, pattern_data in enumerate(patterns_list):&#10;                file.write(&quot;    {\n&quot;)&#10;&#10;                # Write non-pattern fields first&#10;                for key, value in pattern_data.items():&#10;                    if key != 'pattern':&#10;                        if isinstance(value, str):&#10;                            file.write(f'      &quot;{key}&quot;: &quot;{value}&quot;,\n')&#10;                        else:&#10;                            file.write(f'      &quot;{key}&quot;: {value},\n')&#10;&#10;                # Write pattern array with grid formatting&#10;                file.write('      &quot;pattern&quot;: [\n')&#10;                pattern_array = pattern_data['pattern']&#10;&#10;                for row_idx, row in enumerate(pattern_array):&#10;                    file.write(&quot;        [&quot;)&#10;                    row_str = &quot;,&quot;.join(str(val) for val in row)&#10;                    file.write(row_str)&#10;                    if row_idx &lt; len(pattern_array) - 1:&#10;                        file.write(&quot;],\n&quot;)&#10;                    else:&#10;                        file.write(&quot;]\n&quot;)&#10;&#10;                file.write(&quot;      ]\n&quot;)&#10;&#10;                if j &lt; len(patterns_list) - 1:&#10;                    file.write(&quot;    },\n&quot;)&#10;                else:&#10;                    file.write(&quot;    }\n&quot;)&#10;&#10;            if i &lt; len(digit_keys) - 1:&#10;                file.write(&quot;  ],\n&quot;)&#10;            else:&#10;                file.write(&quot;  ]\n&quot;)&#10;&#10;        file.write(&quot;}\n&quot;)&#10;&#10;    def get_pattern_count(self, digit=None):&#10;        &quot;&quot;&quot;Get the count of learned patterns for a digit or all digits&quot;&quot;&quot;&#10;        if digit is not None:&#10;            digit_str = str(digit)&#10;            return len(self.learned_patterns.get(digit_str, []))&#10;        else:&#10;            total = 0&#10;            for patterns in self.learned_patterns.values():&#10;                total += len(patterns)&#10;            return total" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/DigitRecognizer_fixed.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DigitRecognizer_fixed.py" />
              <option name="originalContent" value="import numpy as np&#10;import json&#10;import os&#10;&#10;&#10;class DigitRecognizer:&#10;    &quot;&quot;&quot;&#10;    A class that handles digit recognition, pattern matching, and learning functionality.&#10;    This class is separate from the GUI and focuses purely on the recognition logic.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Grid settings for pattern matching&#10;        self.grid_size = 28  # 28x28 grid for pattern matching&#10;&#10;        # File for storing learned patterns&#10;        self.learned_patterns_file = &quot;learned_patterns.json&quot;&#10;&#10;        # Initialize digit patterns&#10;        self.digit_patterns = self.create_digit_patterns()&#10;&#10;        # Load learned patterns&#10;        self.learned_patterns = self.load_learned_patterns()&#10;&#10;    def preprocess_drawing(self, array):&#10;        &quot;&quot;&quot;Preprocess the drawing array to center and scale it appropriately&quot;&quot;&quot;&#10;        # Find the bounding box of the drawn pixels&#10;        rows, cols = np.where(array &gt; 0)&#10;&#10;        if len(rows) == 0:&#10;            return array  # Empty array&#10;&#10;        min_row, max_row = rows.min(), rows.max()&#10;        min_col, max_col = cols.min(), cols.max()&#10;&#10;        # Extract the drawing within its bounding box&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate if the drawing is too small relative to canvas&#10;        canvas_utilization = (drawing_height * drawing_width) / (self.grid_size * self.grid_size)&#10;&#10;        # If drawing uses less than 25% of the canvas, apply scaling and centering&#10;        if canvas_utilization &lt; 0.25 or drawing_height &lt; self.grid_size * 0.5 or drawing_width &lt; self.grid_size * 0.5:&#10;            return self.center_and_scale_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # If drawing is reasonably sized, center it if it's off-center&#10;        center_row = (min_row + max_row) / 2&#10;        center_col = (min_col + max_col) / 2&#10;        canvas_center = self.grid_size / 2&#10;&#10;        # If drawing is significantly off-center, center it&#10;        if abs(center_row - canvas_center) &gt; 2 or abs(center_col - canvas_center) &gt; 2:&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        return array&#10;&#10;    def center_and_scale_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center and scale up a small drawing to better fill the canvas&quot;&quot;&quot;&#10;        # Extract the drawing&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate scaling factor to make drawing fill more of the canvas&#10;        # Target the drawing to use about 70% of canvas size&#10;        target_size = int(self.grid_size * 0.7)&#10;        scale_factor = min(target_size / drawing_height, target_size / drawing_width)&#10;        scale_factor = min(scale_factor, 3.0)  # Cap scaling to prevent artifacts&#10;&#10;        if scale_factor &lt;= 1.0:&#10;            # If no scaling needed, center&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # Create new array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Calculate new dimensions&#10;        new_height = int(drawing_height * scale_factor)&#10;        new_width = int(drawing_width * scale_factor)&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - new_height) // 2)&#10;        start_col = max(0, (self.grid_size - new_width) // 2)&#10;&#10;        # Scale the drawing using nearest neighbor interpolation&#10;        for i in range(new_height):&#10;            for j in range(new_width):&#10;                orig_row = min_row + int(i / scale_factor)&#10;                orig_col = min_col + int(j / scale_factor)&#10;&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size and&#10;                    orig_row &lt;= max_row and orig_col &lt;= max_col):&#10;                    new_array[start_row + i, start_col + j] = array[orig_row, orig_col]&#10;&#10;        return new_array&#10;&#10;    def center_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center the drawing without scaling&quot;&quot;&quot;&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - drawing_height) // 2)&#10;        start_col = max(0, (self.grid_size - drawing_width) // 2)&#10;&#10;        # Create new centered array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Copy the drawing to center position&#10;        for i in range(drawing_height):&#10;            for j in range(drawing_width):&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size):&#10;                    new_array[start_row + i, start_col + j] = array[min_row + i, min_col + j]&#10;&#10;        return new_array&#10;&#10;    def create_digit_patterns(self):&#10;        &quot;&quot;&quot;Create predefined patterns for digits 0-9 - ALL 28x28&quot;&quot;&quot;&#10;        patterns = {}&#10;&#10;        # Digit 0 patterns - Oval shape (28x28)&#10;        patterns[0] = [&#10;            np.array([&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;                [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;                [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 1 patterns - Straight line (28x28)&#10;        patterns[1] = [&#10;            np.array([&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 2 patterns - S-curve (28x28)&#10;        patterns[2] = [&#10;            np.array([&#10;                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],&#10;                [0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 3 patterns&#10;        patterns[3] = [self._create_simple_digit_3_pattern()]&#10;&#10;        # Digit 4 patterns&#10;        patterns[4] = [self._create_simple_digit_4_pattern()]&#10;&#10;        # Digit 5 patterns&#10;        patterns[5] = [self._create_simple_digit_5_pattern()]&#10;&#10;        # Digit 6 patterns&#10;        patterns[6] = [self._create_simple_digit_6_pattern()]&#10;&#10;        # Digit 7 patterns&#10;        patterns[7] = [self._create_simple_digit_7_pattern()]&#10;&#10;        # Digit 8 patterns&#10;        patterns[8] = [self._create_simple_digit_8_pattern()]&#10;&#10;        # Digit 9 patterns&#10;        patterns[9] = [self._create_simple_digit_9_pattern()]&#10;&#10;        return patterns&#10;&#10;    def _create_simple_digit_3_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 3&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top horizontal line&#10;        pattern[3:6, 2:25] = 1&#10;        # Middle horizontal line&#10;        pattern[12:15, 8:25] = 1&#10;        # Bottom horizontal line&#10;        pattern[22:25, 2:25] = 1&#10;        # Right vertical line&#10;        pattern[6:12, 22:25] = 1&#10;        pattern[15:22, 22:25] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_4_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 4&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Left diagonal line&#10;        for i in range(15):&#10;            pattern[i+3, 14-i] = 1&#10;            pattern[i+3, 15-i] = 1&#10;        # Vertical right line&#10;        pattern[3:25, 17:20] = 1&#10;        # Horizontal line&#10;        pattern[15:18, 2:25] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_5_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 5&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top horizontal line&#10;        pattern[3:6, 2:25] = 1&#10;        # Left vertical line (top part)&#10;        pattern[6:14, 2:5] = 1&#10;        # Middle horizontal line&#10;        pattern[12:15, 2:23] = 1&#10;        # Right vertical line (bottom part)&#10;        pattern[15:22, 20:23] = 1&#10;        # Bottom horizontal line&#10;        pattern[22:25, 2:23] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_6_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 6&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Left vertical line&#10;        pattern[6:22, 4:7] = 1&#10;        # Top curve&#10;        pattern[3:6, 7:20] = 1&#10;        # Middle horizontal line&#10;        pattern[12:15, 7:20] = 1&#10;        # Bottom horizontal line&#10;        pattern[22:25, 7:20] = 1&#10;        # Right vertical line (bottom part)&#10;        pattern[15:22, 20:23] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_7_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 7&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top horizontal line&#10;        pattern[3:6, 2:25] = 1&#10;        # Diagonal line&#10;        for i in range(20):&#10;            col = 22 - i&#10;            row = 6 + i&#10;            if 0 &lt;= col &lt; 28 and 0 &lt;= row &lt; 28:&#10;                pattern[row, col:col+3] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_8_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 8&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top oval&#10;        pattern[3:6, 7:20] = 1&#10;        pattern[6:12, 4:7] = 1&#10;        pattern[6:12, 20:23] = 1&#10;        pattern[10:13, 7:20] = 1&#10;        # Bottom oval&#10;        pattern[12:15, 7:20] = 1&#10;        pattern[15:22, 4:7] = 1&#10;        pattern[15:22, 20:23] = 1&#10;        pattern[22:25, 7:20] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_9_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 9&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top oval&#10;        pattern[3:6, 7:20] = 1&#10;        pattern[6:12, 4:7] = 1&#10;        pattern[6:12, 20:23] = 1&#10;        pattern[12:15, 7:23] = 1&#10;        # Right vertical line&#10;        pattern[15:22, 20:23] = 1&#10;        # Bottom curve&#10;        pattern[22:25, 7:20] = 1&#10;        return pattern&#10;&#10;    def calculate_similarity(self, drawn_array, pattern):&#10;        &quot;&quot;&quot;Calculate similarity between drawn array and pattern using multiple metrics&quot;&quot;&quot;&#10;        # Normalize both arrays to ensure they're binary&#10;        drawn_binary = (drawn_array &gt; 0).astype(int)&#10;        pattern_binary = (pattern &gt; 0).astype(int)&#10;&#10;        # Calculate intersection over union (IoU)&#10;        intersection = np.sum(drawn_binary &amp; pattern_binary)&#10;        union = np.sum(drawn_binary | pattern_binary)&#10;&#10;        if union == 0:&#10;            return 0.0&#10;&#10;        iou = intersection / union&#10;&#10;        # Calculate coverage (how much of the pattern is covered)&#10;        pattern_pixels = np.sum(pattern_binary)&#10;        if pattern_pixels == 0:&#10;            return 0.0&#10;        coverage = intersection / pattern_pixels&#10;&#10;        # Calculate precision (how much of the drawing matches the pattern)&#10;        drawn_pixels = np.sum(drawn_binary)&#10;        if drawn_pixels == 0:&#10;            return 0.0&#10;        precision = intersection / drawn_pixels&#10;&#10;        # Weighted combination of metrics&#10;        similarity = 0.4 * iou + 0.3 * coverage + 0.3 * precision&#10;&#10;        return similarity&#10;&#10;    def predict_digit(self, drawn_array):&#10;        &quot;&quot;&quot;&#10;        Predict the digit based on the drawing array.&#10;        Returns a tuple of (predicted_digit, confidence, all_similarities)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Preprocess the drawing&#10;            processed_array = self.preprocess_drawing(drawn_array)&#10;&#10;            best_digit = None&#10;            best_similarity = 0.0&#10;            similarities = {}&#10;&#10;            # Compare with all patterns (both predefined and learned)&#10;            for digit in range(10):&#10;                max_similarity_for_digit = 0.0&#10;&#10;                # Check predefined patterns&#10;                if digit in self.digit_patterns:&#10;                    for pattern in self.digit_patterns[digit]:&#10;                        similarity = self.calculate_similarity(processed_array, pattern)&#10;                        max_similarity_for_digit = max(max_similarity_for_digit, similarity)&#10;&#10;                # Check learned patterns and give them higher weight&#10;                digit_str = str(digit)&#10;                if digit_str in self.learned_patterns:&#10;                    for pattern_data in self.learned_patterns[digit_str]:&#10;                        try:&#10;                            learned_pattern = np.array(pattern_data['pattern'])&#10;                            learned_similarity = self.calculate_similarity(processed_array, learned_pattern)&#10;                            # Boost learned pattern similarity based on confidence and feedback&#10;                            confidence_boost = 1.0 + (pattern_data.get('confidence', 1.0) * 0.2)&#10;                            feedback_boost = 1.0 + (pattern_data.get('feedback_count', 1) * 0.1)&#10;                            learned_similarity *= confidence_boost * feedback_boost&#10;                            max_similarity_for_digit = max(max_similarity_for_digit, learned_similarity)&#10;                        except (ValueError, KeyError) as e:&#10;                            print(f&quot;Error processing learned pattern for digit {digit}: {e}&quot;)&#10;                            continue&#10;&#10;                similarities[digit] = max_similarity_for_digit&#10;&#10;                if max_similarity_for_digit &gt; best_similarity:&#10;                    best_similarity = max_similarity_for_digit&#10;                    best_digit = digit&#10;&#10;            return best_digit, best_similarity, similarities&#10;&#10;        except Exception as e:&#10;            print(f&quot;Prediction error: {e}&quot;)&#10;            return None, 0.0, {}&#10;&#10;    def add_positive_feedback(self, drawn_array, predicted_digit):&#10;        &quot;&quot;&quot;Add a pattern as a positive example for the predicted digit&quot;&quot;&quot;&#10;        try:&#10;            digit = str(predicted_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit not in self.learned_patterns:&#10;                self.learned_patterns[digit] = []&#10;&#10;            # Add the current drawing as a learned pattern&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1&#10;            }&#10;&#10;            self.learned_patterns[digit].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Positive feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def add_negative_feedback(self, drawn_array, predicted_digit, correct_digit):&#10;        &quot;&quot;&quot;Add a pattern as a correction from predicted_digit to correct_digit&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(correct_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit_str not in self.learned_patterns:&#10;                self.learned_patterns[digit_str] = []&#10;&#10;            # Add the current drawing as a learned pattern with the correct label&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1,&#10;                'corrected_from': predicted_digit&#10;            }&#10;&#10;            self.learned_patterns[digit_str].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Negative feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def remove_last_pattern(self, digit):&#10;        &quot;&quot;&quot;Remove the last pattern added for a digit (used for undo)&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(digit)&#10;            if digit_str in self.learned_patterns and len(self.learned_patterns[digit_str]) &gt; 0:&#10;                self.learned_patterns[digit_str].pop()&#10;&#10;                # If this was the only pattern for this digit, remove the digit entirely&#10;                if len(self.learned_patterns[digit_str]) == 0:&#10;                    del self.learned_patterns[digit_str]&#10;&#10;                return True&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Remove pattern error: {e}&quot;)&#10;            return False&#10;&#10;    def load_learned_patterns(self):&#10;        &quot;&quot;&quot;Load learned patterns from file with error handling&quot;&quot;&quot;&#10;        try:&#10;            if os.path.exists(self.learned_patterns_file):&#10;                with open(self.learned_patterns_file, 'r') as f:&#10;                    data = json.load(f)&#10;                    # Validate the loaded data&#10;                    if isinstance(data, dict):&#10;                        # Convert patterns back to numpy arrays for processing&#10;                        for digit, patterns in data.items():&#10;                            if isinstance(patterns, list):&#10;                                for pattern_data in patterns:&#10;                                    if isinstance(pattern_data, dict) and 'pattern' in pattern_data:&#10;                                        # Pattern data is valid&#10;                                        continue&#10;                                    else:&#10;                                        print(f&quot;Invalid pattern data for digit {digit}&quot;)&#10;                        return data&#10;                    else:&#10;                        print(&quot;Invalid learned patterns file format&quot;)&#10;                        return {}&#10;            else:&#10;                print(&quot;No learned patterns file found, starting fresh&quot;)&#10;                return {}&#10;        except (json.JSONDecodeError, IOError) as e:&#10;            print(f&quot;Error loading learned patterns: {e}&quot;)&#10;            # Try to load backup if available&#10;            backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;            if os.path.exists(backup_file):&#10;                try:&#10;                    with open(backup_file, 'r') as f:&#10;                        print(&quot;Loading from backup file&quot;)&#10;                        return json.load(f)&#10;                except:&#10;                    print(&quot;Backup file also corrupted&quot;)&#10;            return {}&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error loading patterns: {e}&quot;)&#10;            return {}&#10;&#10;    def save_learned_patterns(self):&#10;        &quot;&quot;&quot;Save learned patterns to file with backup and error handling&quot;&quot;&quot;&#10;        try:&#10;            # Create backup of existing file&#10;            if os.path.exists(self.learned_patterns_file):&#10;                backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;                try:&#10;                    import shutil&#10;                    shutil.copy2(self.learned_patterns_file, backup_file)&#10;                except Exception as backup_error:&#10;                    print(f&quot;Warning: Could not create backup: {backup_error}&quot;)&#10;&#10;            # Save current patterns with custom formatting&#10;            with open(self.learned_patterns_file, 'w') as f:&#10;                self._write_formatted_patterns(f, self.learned_patterns)&#10;&#10;            print(f&quot;Learned patterns saved successfully to {self.learned_patterns_file}&quot;)&#10;            return True&#10;&#10;        except (IOError, json.JSONEncodeError) as e:&#10;            print(f&quot;Failed to save learned patterns: {e}&quot;)&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error saving patterns: {e}&quot;)&#10;            return False&#10;&#10;    def _write_formatted_patterns(self, file, patterns_dict):&#10;        &quot;&quot;&quot;Write patterns to file with readable array formatting&quot;&quot;&quot;&#10;        file.write(&quot;{\n&quot;)&#10;&#10;        digit_keys = sorted(patterns_dict.keys(), key=lambda x: int(x))&#10;&#10;        for i, digit in enumerate(digit_keys):&#10;            patterns_list = patterns_dict[digit]&#10;            file.write(f'  &quot;{digit}&quot;: [\n')&#10;&#10;            for j, pattern_data in enumerate(patterns_list):&#10;                file.write(&quot;    {\n&quot;)&#10;&#10;                # Write non-pattern fields first&#10;                for key, value in pattern_data.items():&#10;                    if key != 'pattern':&#10;                        if isinstance(value, str):&#10;                            file.write(f'      &quot;{key}&quot;: &quot;{value}&quot;,\n')&#10;                        else:&#10;                            file.write(f'      &quot;{key}&quot;: {value},\n')&#10;&#10;                # Write pattern array with grid formatting&#10;                file.write('      &quot;pattern&quot;: [\n')&#10;                pattern_array = pattern_data['pattern']&#10;&#10;                for row_idx, row in enumerate(pattern_array):&#10;                    file.write(&quot;        [&quot;)&#10;                    row_str = &quot;,&quot;.join(str(val) for val in row)&#10;                    file.write(row_str)&#10;                    if row_idx &lt; len(pattern_array) - 1:&#10;                        file.write(&quot;],\n&quot;)&#10;                    else:&#10;                        file.write(&quot;]\n&quot;)&#10;&#10;                file.write(&quot;      ]\n&quot;)&#10;&#10;                if j &lt; len(patterns_list) - 1:&#10;                    file.write(&quot;    },\n&quot;)&#10;                else:&#10;                    file.write(&quot;    }\n&quot;)&#10;&#10;            if i &lt; len(digit_keys) - 1:&#10;                file.write(&quot;  ],\n&quot;)&#10;            else:&#10;                file.write(&quot;  ]\n&quot;)&#10;&#10;        file.write(&quot;}\n&quot;)&#10;&#10;    def get_pattern_count(self, digit=None):&#10;        &quot;&quot;&quot;Get the count of learned patterns for a digit or all digits&quot;&quot;&quot;&#10;        if digit is not None:&#10;            digit_str = str(digit)&#10;            return len(self.learned_patterns.get(digit_str, []))&#10;        else:&#10;            total = 0&#10;            for patterns in self.learned_patterns.values():&#10;                total += len(patterns)&#10;            return total&#10;" />
              <option name="updatedContent" value="import numpy as np&#10;import json&#10;import os&#10;&#10;&#10;class DigitRecognizer:&#10;    &quot;&quot;&quot;&#10;    A class that handles digit recognition, pattern matching, and learning functionality.&#10;    This class is separate from the GUI and focuses purely on the recognition logic.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        # Grid settings for pattern matching&#10;        self.grid_size = 28  # 28x28 grid for pattern matching&#10;&#10;        # File for storing learned patterns&#10;        self.learned_patterns_file = &quot;learned_patterns.json&quot;&#10;&#10;        # Initialize digit patterns&#10;        self.digit_patterns = self.create_digit_patterns()&#10;&#10;        # Load learned patterns&#10;        self.learned_patterns = self.load_learned_patterns()&#10;&#10;    def preprocess_drawing(self, array):&#10;        &quot;&quot;&quot;Preprocess the drawing array to center and scale it appropriately&quot;&quot;&quot;&#10;        # Find the bounding box of the drawn pixels&#10;        rows, cols = np.where(array &gt; 0)&#10;&#10;        if len(rows) == 0:&#10;            return array  # Empty array&#10;&#10;        min_row, max_row = rows.min(), rows.max()&#10;        min_col, max_col = cols.min(), cols.max()&#10;&#10;        # Extract the drawing within its bounding box&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate if the drawing is too small relative to canvas&#10;        canvas_utilization = (drawing_height * drawing_width) / (self.grid_size * self.grid_size)&#10;&#10;        # If drawing uses less than 25% of the canvas, apply scaling and centering&#10;        if canvas_utilization &lt; 0.25 or drawing_height &lt; self.grid_size * 0.5 or drawing_width &lt; self.grid_size * 0.5:&#10;            return self.center_and_scale_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # If drawing is reasonably sized, center it if it's off-center&#10;        center_row = (min_row + max_row) / 2&#10;        center_col = (min_col + max_col) / 2&#10;        canvas_center = self.grid_size / 2&#10;&#10;        # If drawing is significantly off-center, center it&#10;        if abs(center_row - canvas_center) &gt; 2 or abs(center_col - canvas_center) &gt; 2:&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        return array&#10;&#10;    def center_and_scale_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center and scale up a small drawing to better fill the canvas&quot;&quot;&quot;&#10;        # Extract the drawing&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate scaling factor to make drawing fill more of the canvas&#10;        # Target the drawing to use about 70% of canvas size&#10;        target_size = int(self.grid_size * 0.7)&#10;        scale_factor = min(target_size / drawing_height, target_size / drawing_width)&#10;        scale_factor = min(scale_factor, 3.0)  # Cap scaling to prevent artifacts&#10;&#10;        if scale_factor &lt;= 1.0:&#10;            # If no scaling needed, center&#10;            return self.center_drawing(array, min_row, max_row, min_col, max_col)&#10;&#10;        # Create new array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Calculate new dimensions&#10;        new_height = int(drawing_height * scale_factor)&#10;        new_width = int(drawing_width * scale_factor)&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - new_height) // 2)&#10;        start_col = max(0, (self.grid_size - new_width) // 2)&#10;&#10;        # Scale the drawing using nearest neighbor interpolation&#10;        for i in range(new_height):&#10;            for j in range(new_width):&#10;                orig_row = min_row + int(i / scale_factor)&#10;                orig_col = min_col + int(j / scale_factor)&#10;&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size and&#10;                    orig_row &lt;= max_row and orig_col &lt;= max_col):&#10;                    new_array[start_row + i, start_col + j] = array[orig_row, orig_col]&#10;&#10;        return new_array&#10;&#10;    def center_drawing(self, array, min_row, max_row, min_col, max_col):&#10;        &quot;&quot;&quot;Center the drawing without scaling&quot;&quot;&quot;&#10;        drawing_height = max_row - min_row + 1&#10;        drawing_width = max_col - min_col + 1&#10;&#10;        # Calculate center position&#10;        start_row = max(0, (self.grid_size - drawing_height) // 2)&#10;        start_col = max(0, (self.grid_size - drawing_width) // 2)&#10;&#10;        # Create new centered array&#10;        new_array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;&#10;        # Copy the drawing to center position&#10;        for i in range(drawing_height):&#10;            for j in range(drawing_width):&#10;                if (start_row + i &lt; self.grid_size and start_col + j &lt; self.grid_size):&#10;                    new_array[start_row + i, start_col + j] = array[min_row + i, min_col + j]&#10;&#10;        return new_array&#10;&#10;    def create_digit_patterns(self):&#10;        &quot;&quot;&quot;Create predefined patterns for digits 0-9 - ALL 28x28&quot;&quot;&quot;&#10;        patterns = {}&#10;&#10;        # Digit 0 patterns - Oval shape (28x28)&#10;        patterns[0] = [&#10;            np.array([&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;                [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;                [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;                [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;                [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;                [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 1 patterns - Straight line (28x28)&#10;        patterns[1] = [&#10;            np.array([&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 2 patterns - S-curve (28x28)&#10;        patterns[2] = [&#10;            np.array([&#10;                [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],&#10;                [0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;                [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ])&#10;        ]&#10;&#10;        # Digit 3 patterns&#10;        patterns[3] = [self._create_simple_digit_3_pattern()]&#10;&#10;        # Digit 4 patterns&#10;        patterns[4] = [self._create_simple_digit_4_pattern()]&#10;&#10;        # Digit 5 patterns&#10;        patterns[5] = [self._create_simple_digit_5_pattern()]&#10;&#10;        # Digit 6 patterns&#10;        patterns[6] = [self._create_simple_digit_6_pattern()]&#10;&#10;        # Digit 7 patterns&#10;        patterns[7] = [self._create_simple_digit_7_pattern()]&#10;&#10;        # Digit 8 patterns&#10;        patterns[8] = [self._create_simple_digit_8_pattern()]&#10;&#10;        # Digit 9 patterns&#10;        patterns[9] = [self._create_simple_digit_9_pattern()]&#10;&#10;        return patterns&#10;&#10;    def _create_simple_digit_3_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 3&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top horizontal line&#10;        pattern[3:6, 2:25] = 1&#10;        # Middle horizontal line&#10;        pattern[12:15, 8:25] = 1&#10;        # Bottom horizontal line&#10;        pattern[22:25, 2:25] = 1&#10;        # Right vertical line&#10;        pattern[6:12, 22:25] = 1&#10;        pattern[15:22, 22:25] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_4_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 4&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Left diagonal line&#10;        for i in range(15):&#10;            pattern[i+3, 14-i] = 1&#10;            pattern[i+3, 15-i] = 1&#10;        # Vertical right line&#10;        pattern[3:25, 17:20] = 1&#10;        # Horizontal line&#10;        pattern[15:18, 2:25] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_5_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 5&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top horizontal line&#10;        pattern[3:6, 2:25] = 1&#10;        # Left vertical line (top part)&#10;        pattern[6:14, 2:5] = 1&#10;        # Middle horizontal line&#10;        pattern[12:15, 2:23] = 1&#10;        # Right vertical line (bottom part)&#10;        pattern[15:22, 20:23] = 1&#10;        # Bottom horizontal line&#10;        pattern[22:25, 2:23] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_6_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 6&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Left vertical line&#10;        pattern[6:22, 4:7] = 1&#10;        # Top curve&#10;        pattern[3:6, 7:20] = 1&#10;        pattern[6:12, 4:7] = 1&#10;        pattern[6:12, 20:23] = 1&#10;        pattern[10:13, 7:20] = 1&#10;        # Middle horizontal line&#10;        pattern[12:15, 7:20] = 1&#10;        # Bottom horizontal line&#10;        pattern[22:25, 7:20] = 1&#10;        # Right vertical line (bottom part)&#10;        pattern[15:22, 20:23] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_7_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 7&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top horizontal line&#10;        pattern[3:6, 2:25] = 1&#10;        # Diagonal line&#10;        for i in range(20):&#10;            col = 22 - i&#10;            row = 6 + i&#10;            if 0 &lt;= col &lt; 28 and 0 &lt;= row &lt; 28:&#10;                pattern[row, col:col+3] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_8_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 8&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top oval&#10;        pattern[3:6, 7:20] = 1&#10;        pattern[6:12, 4:7] = 1&#10;        pattern[6:12, 20:23] = 1&#10;        pattern[10:13, 7:20] = 1&#10;        # Bottom oval&#10;        pattern[12:15, 7:20] = 1&#10;        pattern[15:22, 4:7] = 1&#10;        pattern[15:22, 20:23] = 1&#10;        pattern[22:25, 7:20] = 1&#10;        return pattern&#10;&#10;    def _create_simple_digit_9_pattern(self):&#10;        &quot;&quot;&quot;Create a simple 28x28 pattern for digit 9&quot;&quot;&quot;&#10;        pattern = np.zeros((28, 28), dtype=int)&#10;        # Top oval&#10;        pattern[3:6, 7:20] = 1&#10;        pattern[6:12, 4:7] = 1&#10;        pattern[6:12, 20:23] = 1&#10;        pattern[12:15, 7:23] = 1&#10;        # Right vertical line&#10;        pattern[15:22, 20:23] = 1&#10;        # Bottom curve&#10;        pattern[22:25, 7:20] = 1&#10;        return pattern&#10;&#10;    def calculate_similarity(self, drawn_array, pattern):&#10;        &quot;&quot;&quot;Calculate similarity between drawn array and pattern using multiple metrics&quot;&quot;&quot;&#10;        # Normalize both arrays to ensure they're binary&#10;        drawn_binary = (drawn_array &gt; 0).astype(int)&#10;        pattern_binary = (pattern &gt; 0).astype(int)&#10;&#10;        # Calculate intersection over union (IoU)&#10;        intersection = np.sum(drawn_binary &amp; pattern_binary)&#10;        union = np.sum(drawn_binary | pattern_binary)&#10;&#10;        if union == 0:&#10;            return 0.0&#10;&#10;        iou = intersection / union&#10;&#10;        # Calculate coverage (how much of the pattern is covered)&#10;        pattern_pixels = np.sum(pattern_binary)&#10;        if pattern_pixels == 0:&#10;            return 0.0&#10;        coverage = intersection / pattern_pixels&#10;&#10;        # Calculate precision (how much of the drawing matches the pattern)&#10;        drawn_pixels = np.sum(drawn_binary)&#10;        if drawn_pixels == 0:&#10;            return 0.0&#10;        precision = intersection / drawn_pixels&#10;&#10;        # Weighted combination of metrics&#10;        similarity = 0.4 * iou + 0.3 * coverage + 0.3 * precision&#10;&#10;        return similarity&#10;&#10;    def predict_digit(self, drawn_array):&#10;        &quot;&quot;&quot;&#10;        Predict the digit based on the drawing array.&#10;        Returns a tuple of (predicted_digit, confidence, all_similarities)&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Preprocess the drawing&#10;            processed_array = self.preprocess_drawing(drawn_array)&#10;&#10;            best_digit = None&#10;            best_similarity = 0.0&#10;            similarities = {}&#10;&#10;            # Compare with all patterns (both predefined and learned)&#10;            for digit in range(10):&#10;                max_similarity_for_digit = 0.0&#10;&#10;                # Check predefined patterns&#10;                if digit in self.digit_patterns:&#10;                    for pattern in self.digit_patterns[digit]:&#10;                        similarity = self.calculate_similarity(processed_array, pattern)&#10;                        max_similarity_for_digit = max(max_similarity_for_digit, similarity)&#10;&#10;                # Check learned patterns and give them higher weight&#10;                digit_str = str(digit)&#10;                if digit_str in self.learned_patterns:&#10;                    for pattern_data in self.learned_patterns[digit_str]:&#10;                        try:&#10;                            learned_pattern = np.array(pattern_data['pattern'])&#10;                            learned_similarity = self.calculate_similarity(processed_array, learned_pattern)&#10;                            # Boost learned pattern similarity based on confidence and feedback&#10;                            confidence_boost = 1.0 + (pattern_data.get('confidence', 1.0) * 0.2)&#10;                            feedback_boost = 1.0 + (pattern_data.get('feedback_count', 1) * 0.1)&#10;                            learned_similarity *= confidence_boost * feedback_boost&#10;                            max_similarity_for_digit = max(max_similarity_for_digit, learned_similarity)&#10;                        except (ValueError, KeyError) as e:&#10;                            print(f&quot;Error processing learned pattern for digit {digit}: {e}&quot;)&#10;                            continue&#10;&#10;                similarities[digit] = max_similarity_for_digit&#10;&#10;                if max_similarity_for_digit &gt; best_similarity:&#10;                    best_similarity = max_similarity_for_digit&#10;                    best_digit = digit&#10;&#10;            return best_digit, best_similarity, similarities&#10;&#10;        except Exception as e:&#10;            print(f&quot;Prediction error: {e}&quot;)&#10;            return None, 0.0, {}&#10;&#10;    def add_positive_feedback(self, drawn_array, predicted_digit):&#10;        &quot;&quot;&quot;Add a pattern as a positive example for the predicted digit&quot;&quot;&quot;&#10;        try:&#10;            digit = str(predicted_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit not in self.learned_patterns:&#10;                self.learned_patterns[digit] = []&#10;&#10;            # Add the current drawing as a learned pattern&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1&#10;            }&#10;&#10;            self.learned_patterns[digit].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Positive feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def add_negative_feedback(self, drawn_array, predicted_digit, correct_digit):&#10;        &quot;&quot;&quot;Add a pattern as a correction from predicted_digit to correct_digit&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(correct_digit)&#10;&#10;            # Initialize if first time for this digit&#10;            if digit_str not in self.learned_patterns:&#10;                self.learned_patterns[digit_str] = []&#10;&#10;            # Add the current drawing as a learned pattern with the correct label&#10;            pattern_data = {&#10;                'pattern': drawn_array.tolist(),&#10;                'confidence': 1.0,&#10;                'feedback_count': 1,&#10;                'corrected_from': predicted_digit&#10;            }&#10;&#10;            self.learned_patterns[digit_str].append(pattern_data)&#10;            return True&#10;&#10;        except Exception as e:&#10;            print(f&quot;Negative feedback error: {e}&quot;)&#10;            return False&#10;&#10;    def remove_last_pattern(self, digit):&#10;        &quot;&quot;&quot;Remove the last pattern added for a digit (used for undo)&quot;&quot;&quot;&#10;        try:&#10;            digit_str = str(digit)&#10;            if digit_str in self.learned_patterns and len(self.learned_patterns[digit_str]) &gt; 0:&#10;                self.learned_patterns[digit_str].pop()&#10;&#10;                # If this was the only pattern for this digit, remove the digit entirely&#10;                if len(self.learned_patterns[digit_str]) == 0:&#10;                    del self.learned_patterns[digit_str]&#10;&#10;                return True&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Remove pattern error: {e}&quot;)&#10;            return False&#10;&#10;    def load_learned_patterns(self):&#10;        &quot;&quot;&quot;Load learned patterns from file with error handling&quot;&quot;&quot;&#10;        try:&#10;            if os.path.exists(self.learned_patterns_file):&#10;                with open(self.learned_patterns_file, 'r') as f:&#10;                    data = json.load(f)&#10;                    # Validate the loaded data&#10;                    if isinstance(data, dict):&#10;                        # Convert patterns back to numpy arrays for processing&#10;                        for digit, patterns in data.items():&#10;                            if isinstance(patterns, list):&#10;                                for pattern_data in patterns:&#10;                                    if isinstance(pattern_data, dict) and 'pattern' in pattern_data:&#10;                                        # Pattern data is valid&#10;                                        continue&#10;                                    else:&#10;                                        print(f&quot;Invalid pattern data for digit {digit}&quot;)&#10;                        return data&#10;                    else:&#10;                        print(&quot;Invalid learned patterns file format&quot;)&#10;                        return {}&#10;            else:&#10;                print(&quot;No learned patterns file found, starting fresh&quot;)&#10;                return {}&#10;        except (json.JSONDecodeError, IOError) as e:&#10;            print(f&quot;Error loading learned patterns: {e}&quot;)&#10;            # Try to load backup if available&#10;            backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;            if os.path.exists(backup_file):&#10;                try:&#10;                    with open(backup_file, 'r') as f:&#10;                        print(&quot;Loading from backup file&quot;)&#10;                        return json.load(f)&#10;                except:&#10;                    print(&quot;Backup file also corrupted&quot;)&#10;            return {}&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error loading patterns: {e}&quot;)&#10;            return {}&#10;&#10;    def save_learned_patterns(self):&#10;        &quot;&quot;&quot;Save learned patterns to file with backup and error handling&quot;&quot;&quot;&#10;        try:&#10;            # Create backup of existing file&#10;            if os.path.exists(self.learned_patterns_file):&#10;                backup_file = self.learned_patterns_file + &quot;.backup&quot;&#10;                try:&#10;                    import shutil&#10;                    shutil.copy2(self.learned_patterns_file, backup_file)&#10;                except Exception as backup_error:&#10;                    print(f&quot;Warning: Could not create backup: {backup_error}&quot;)&#10;&#10;            # Save current patterns with custom formatting&#10;            with open(self.learned_patterns_file, 'w') as f:&#10;                self._write_formatted_patterns(f, self.learned_patterns)&#10;&#10;            print(f&quot;Learned patterns saved successfully to {self.learned_patterns_file}&quot;)&#10;            return True&#10;&#10;        except (IOError, json.JSONEncodeError) as e:&#10;            print(f&quot;Failed to save learned patterns: {e}&quot;)&#10;            return False&#10;        except Exception as e:&#10;            print(f&quot;Unexpected error saving patterns: {e}&quot;)&#10;            return False&#10;&#10;    def _write_formatted_patterns(self, file, patterns_dict):&#10;        &quot;&quot;&quot;Write patterns to file with readable array formatting&quot;&quot;&quot;&#10;        file.write(&quot;{\n&quot;)&#10;&#10;        digit_keys = sorted(patterns_dict.keys(), key=lambda x: int(x))&#10;&#10;        for i, digit in enumerate(digit_keys):&#10;            patterns_list = patterns_dict[digit]&#10;            file.write(f'  &quot;{digit}&quot;: [\n')&#10;&#10;            for j, pattern_data in enumerate(patterns_list):&#10;                file.write(&quot;    {\n&quot;)&#10;&#10;                # Write non-pattern fields first&#10;                for key, value in pattern_data.items():&#10;                    if key != 'pattern':&#10;                        if isinstance(value, str):&#10;                            file.write(f'      &quot;{key}&quot;: &quot;{value}&quot;,\n')&#10;                        else:&#10;                            file.write(f'      &quot;{key}&quot;: {value},\n')&#10;&#10;                # Write pattern array with grid formatting&#10;                file.write('      &quot;pattern&quot;: [\n')&#10;                pattern_array = pattern_data['pattern']&#10;&#10;                for row_idx, row in enumerate(pattern_array):&#10;                    file.write(&quot;        [&quot;)&#10;                    row_str = &quot;,&quot;.join(str(val) for val in row)&#10;                    file.write(row_str)&#10;                    if row_idx &lt; len(pattern_array) - 1:&#10;                        file.write(&quot;],\n&quot;)&#10;                    else:&#10;                        file.write(&quot;]\n&quot;)&#10;&#10;                file.write(&quot;      ]\n&quot;)&#10;&#10;                if j &lt; len(patterns_list) - 1:&#10;                    file.write(&quot;    },\n&quot;)&#10;                else:&#10;                    file.write(&quot;    }\n&quot;)&#10;&#10;            if i &lt; len(digit_keys) - 1:&#10;                file.write(&quot;  ],\n&quot;)&#10;            else:&#10;                file.write(&quot;  ]\n&quot;)&#10;&#10;        file.write(&quot;}\n&quot;)&#10;&#10;    def get_pattern_count(self, digit=None):&#10;        &quot;&quot;&quot;Get the count of learned patterns for a digit or all digits&quot;&quot;&quot;&#10;        if digit is not None:&#10;            digit_str = str(digit)&#10;            return len(self.learned_patterns.get(digit_str, []))&#10;        else:&#10;            total = 0&#10;            for patterns in self.learned_patterns.values():&#10;                total += len(patterns)&#10;            return total&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/convert_patterns_to_28x28.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/convert_patterns_to_28x28.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Script to convert 14x14 patterns to 28x28 patterns by upscaling.&#10;This will update both the learned patterns and create new predefined patterns.&#10;&quot;&quot;&quot;&#10;&#10;import json&#10;import numpy as np&#10;import os&#10;&#10;def upscale_pattern_14_to_28(pattern_14x14):&#10;    &quot;&quot;&quot;Convert a 14x14 pattern to 28x28 by doubling each pixel&quot;&quot;&quot;&#10;    pattern_array = np.array(pattern_14x14)&#10;    if pattern_array.shape != (14, 14):&#10;        print(f&quot;Warning: Pattern shape is {pattern_array.shape}, expected (14, 14)&quot;)&#10;        return pattern_14x14&#10;    &#10;    # Create 28x28 array&#10;    pattern_28x28 = np.zeros((28, 28), dtype=int)&#10;    &#10;    # Double each pixel - map each 14x14 pixel to a 2x2 block in 28x28&#10;    for i in range(14):&#10;        for j in range(14):&#10;            value = pattern_array[i, j]&#10;            # Map each 14x14 pixel to a 2x2 block in 28x28&#10;            pattern_28x28[i*2:i*2+2, j*2:j*2+2] = value&#10;    &#10;    return pattern_28x28.tolist()&#10;&#10;def convert_learned_patterns():&#10;    &quot;&quot;&quot;Convert all learned patterns from 14x14 to 28x28&quot;&quot;&quot;&#10;    input_file = &quot;learned_patterns.json&quot;&#10;    output_file = &quot;learned_patterns_28x28.json&quot;&#10;    backup_file = &quot;learned_patterns_14x14_backup.json&quot;&#10;    &#10;    if not os.path.exists(input_file):&#10;        print(f&quot;No {input_file} found to convert&quot;)&#10;        return False&#10;    &#10;    # Create backup of original&#10;    try:&#10;        import shutil&#10;        shutil.copy2(input_file, backup_file)&#10;        print(f&quot;Created backup: {backup_file}&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Warning: Could not create backup: {e}&quot;)&#10;    &#10;    try:&#10;        with open(input_file, 'r') as f:&#10;            data = json.load(f)&#10;        &#10;        converted_data = {}&#10;        total_patterns = 0&#10;        converted_patterns = 0&#10;        &#10;        for digit, patterns_list in data.items():&#10;            converted_data[digit] = []&#10;            &#10;            for pattern_data in patterns_list:&#10;                if 'pattern' in pattern_data:&#10;                    total_patterns += 1&#10;                    original_pattern = pattern_data['pattern']&#10;                    &#10;                    # Check if it's 14x14&#10;                    if len(original_pattern) == 14 and all(len(row) == 14 for row in original_pattern):&#10;                        # Convert to 28x28&#10;                        new_pattern = upscale_pattern_14_to_28(original_pattern)&#10;                        &#10;                        # Create new pattern data&#10;                        new_pattern_data = pattern_data.copy()&#10;                        new_pattern_data['pattern'] = new_pattern&#10;                        &#10;                        converted_data[digit].append(new_pattern_data)&#10;                        converted_patterns += 1&#10;                        &#10;                        print(f&quot;Converted pattern for digit {digit}&quot;)&#10;                    &#10;                    elif len(original_pattern) == 28 and all(len(row) == 28 for row in original_pattern):&#10;                        # Already 28x28, keep as is&#10;                        converted_data[digit].append(pattern_data)&#10;                        print(f&quot;Pattern for digit {digit} already 28x28&quot;)&#10;                    &#10;                    else:&#10;                        print(f&quot;Warning: Unusual pattern size for digit {digit}: {len(original_pattern)}x{len(original_pattern[0]) if original_pattern else 0}&quot;)&#10;                        # Keep original pattern as is&#10;                        converted_data[digit].append(pattern_data)&#10;        &#10;        # Write converted data&#10;        with open(output_file, 'w') as f:&#10;            json.dump(converted_data, f, indent=2)&#10;        &#10;        print(f&quot;\nConversion complete!&quot;)&#10;        print(f&quot;Total patterns processed: {total_patterns}&quot;)&#10;        print(f&quot;Patterns converted: {converted_patterns}&quot;)&#10;        print(f&quot;Output saved to: {output_file}&quot;)&#10;        &#10;        # Replace original with converted&#10;        try:&#10;            os.rename(output_file, input_file)&#10;            print(f&quot;Replaced original {input_file} with converted patterns&quot;)&#10;        except Exception as e:&#10;            print(f&quot;Error replacing original file: {e}&quot;)&#10;            print(f&quot;Converted patterns are available in {output_file}&quot;)&#10;        &#10;        return True&#10;        &#10;    except Exception as e:&#10;        print(f&quot;Error converting patterns: {e}&quot;)&#10;        return False&#10;&#10;def create_28x28_predefined_patterns():&#10;    &quot;&quot;&quot;Create new 28x28 predefined patterns by upscaling the 14x14 ones&quot;&quot;&quot;&#10;    &#10;    # Original 14x14 patterns for reference&#10;    patterns_14x14 = {&#10;        0: [&#10;            [&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,0,0,0,0,0,0,0,0,0,0,1,1],&#10;                [1,1,1,0,0,0,0,0,0,0,0,1,1,1],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,1,1,1,1,1,1,1,1,1,1,0,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ]&#10;        ],&#10;        1: [&#10;            [&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,1,1,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;                [0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;            ]&#10;        ]&#10;        # Add more patterns as needed&#10;    }&#10;    &#10;    print(&quot;Creating upscaled 28x28 predefined patterns...&quot;)&#10;    &#10;    patterns_28x28 = {}&#10;    for digit, pattern_list in patterns_14x14.items():&#10;        patterns_28x28[digit] = []&#10;        for pattern_14 in pattern_list:&#10;            pattern_28 = upscale_pattern_14_to_28(pattern_14)&#10;            patterns_28x28[digit].append(pattern_28)&#10;            print(f&quot;Created 28x28 pattern for digit {digit}&quot;)&#10;    &#10;    return patterns_28x28&#10;&#10;def display_pattern(pattern, title=&quot;Pattern&quot;):&#10;    &quot;&quot;&quot;Display a pattern in a readable format&quot;&quot;&quot;&#10;    print(f&quot;\n{title}:&quot;)&#10;    print(&quot;-&quot; * len(title))&#10;    for row in pattern:&#10;        print(''.join(['█' if pixel else '·' for pixel in row]))&#10;&#10;def test_conversion():&#10;    &quot;&quot;&quot;Test the conversion with a sample pattern&quot;&quot;&quot;&#10;    print(&quot;Testing conversion with a sample 14x14 pattern...&quot;)&#10;    &#10;    # Sample 14x14 pattern (simple cross)&#10;    test_pattern_14 = [&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,0,0,0,0,0,0]&#10;    ]&#10;    &#10;    test_pattern_28 = upscale_pattern_14_to_28(test_pattern_14)&#10;    &#10;    display_pattern(test_pattern_14, &quot;Original 14x14 Pattern&quot;)&#10;    display_pattern(test_pattern_28, &quot;Upscaled 28x28 Pattern&quot;)&#10;    &#10;    print(f&quot;\nOriginal size: {len(test_pattern_14)}x{len(test_pattern_14[0])}&quot;)&#10;    print(f&quot;Upscaled size: {len(test_pattern_28)}x{len(test_pattern_28[0])}&quot;)&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    print(&quot;Pattern Resolution Converter: 14x14 → 28x28&quot;)&#10;    print(&quot;=&quot; * 50)&#10;    &#10;    # Test the conversion first&#10;    test_conversion()&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 50)&#10;    print(&quot;Converting learned patterns...&quot;)&#10;    &#10;    # Convert learned patterns&#10;    if convert_learned_patterns():&#10;        print(&quot;\n✓ Learned patterns converted successfully!&quot;)&#10;    else:&#10;        print(&quot;\n✗ Failed to convert learned patterns&quot;)&#10;    &#10;    print(&quot;\n&quot; + &quot;=&quot; * 50)&#10;    print(&quot;Pattern conversion completed!&quot;)&#10;    print(&quot;\nNext steps:&quot;)&#10;    print(&quot;1. The learned patterns have been converted to 28x28&quot;)&#10;    print(&quot;2. Update the predefined patterns in DigitRecognizer.py to 28x28&quot;)&#10;    print(&quot;3. Run the main application to test with the new resolution&quot;)&#10;    print(&quot;4. All new patterns will be stored as 28x28 arrays&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/digit_recognizer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/digit_recognizer.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Handwritten Digit Recognition App&#10;Based on successful open-source implementations and best practices&#10;&quot;&quot;&quot;&#10;&#10;import tkinter as tk&#10;from tkinter import ttk&#10;import torch&#10;import torch.nn as nn&#10;import torch.nn.functional as F&#10;import torch.optim as optim&#10;from PIL import Image, ImageDraw, ImageOps&#10;import numpy as np&#10;import cv2&#10;import os&#10;from scipy import ndimage&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;class LeNet5(nn.Module):&#10;    &quot;&quot;&quot;&#10;    Classic LeNet-5 architecture - proven to work well for digit recognition&#10;    Based on Yann LeCun's original paper and modern implementations&#10;    &quot;&quot;&quot;&#10;    def __init__(self):&#10;        super(LeNet5, self).__init__()&#10;        self.conv1 = nn.Conv2d(1, 6, kernel_size=5)&#10;        self.conv2 = nn.Conv2d(6, 16, kernel_size=5)&#10;        self.fc1 = nn.Linear(16 * 4 * 4, 120)&#10;        self.fc2 = nn.Linear(120, 84)&#10;        self.fc3 = nn.Linear(84, 10)&#10;        &#10;    def forward(self, x):&#10;        x = F.max_pool2d(F.relu(self.conv1(x)), 2)&#10;        x = F.max_pool2d(F.relu(self.conv2(x)), 2)&#10;        x = x.view(-1, 16 * 4 * 4)&#10;        x = F.relu(self.fc1(x))&#10;        x = F.relu(self.fc2(x))&#10;        x = self.fc3(x)&#10;        return x&#10;&#10;&#10;def create_synthetic_mnist_data():&#10;    &quot;&quot;&quot;&#10;    Create synthetic MNIST-like data based on common patterns&#10;    This approach is used in many successful digit recognition projects&#10;    &quot;&quot;&quot;&#10;    def create_digit_0():&#10;        patterns = []&#10;        # Circle-like patterns for 0&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            center_x, center_y = 14, 14&#10;            radius = np.random.randint(8, 12)&#10;            thickness = np.random.randint(2, 4)&#10;            &#10;            # Create circle&#10;            y, x = np.ogrid[:28, :28]&#10;            mask = (x - center_x)**2 + (y - center_y)**2 &lt;= radius**2&#10;            inner_mask = (x - center_x)**2 + (y - center_y)**2 &lt;= (radius - thickness)**2&#10;            img[mask &amp; ~inner_mask] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_1():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Vertical line for 1&#10;            x_pos = np.random.randint(10, 18)&#10;            y_start = np.random.randint(2, 5)&#10;            y_end = np.random.randint(23, 26)&#10;            thickness = np.random.randint(2, 4)&#10;            &#10;            for t in range(thickness):&#10;                img[y_start:y_end, x_pos + t] = 1&#10;            &#10;            # Add small top stroke&#10;            if np.random.random() &gt; 0.5:&#10;                img[y_start:y_start+3, x_pos-2:x_pos] = 1&#10;                &#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_2():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Top horizontal line&#10;            img[5:8, 6:22] = 1&#10;            # Diagonal line&#10;            for i in range(10):&#10;                y = 8 + i&#10;                x = 22 - i&#10;                if 0 &lt;= y &lt; 28 and 0 &lt;= x &lt; 28:&#10;                    img[y:y+2, x:x+2] = 1&#10;            # Bottom horizontal line&#10;            img[20:23, 6:22] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_3():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Top horizontal&#10;            img[5:8, 8:20] = 1&#10;            # Middle horizontal&#10;            img[12:15, 8:18] = 1&#10;            # Bottom horizontal&#10;            img[20:23, 8:20] = 1&#10;            # Right vertical&#10;            img[8:12, 17:20] = 1&#10;            img[15:20, 17:20] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_4():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Left vertical&#10;            img[5:15, 8:11] = 1&#10;            # Right vertical&#10;            img[5:23, 16:19] = 1&#10;            # Horizontal connector&#10;            img[12:15, 8:19] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_5():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Top horizontal&#10;            img[5:8, 8:20] = 1&#10;            # Left vertical (top part)&#10;            img[8:14, 8:11] = 1&#10;            # Middle horizontal&#10;            img[12:15, 8:18] = 1&#10;            # Right vertical (bottom part)&#10;            img[15:20, 15:18] = 1&#10;            # Bottom horizontal&#10;            img[20:23, 8:18] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_6():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Left vertical&#10;            img[5:23, 8:11] = 1&#10;            # Top horizontal (partial)&#10;            img[5:8, 8:16] = 1&#10;            # Middle horizontal&#10;            img[12:15, 8:18] = 1&#10;            # Bottom horizontal&#10;            img[20:23, 8:18] = 1&#10;            # Right vertical (bottom part only)&#10;            img[15:20, 15:18] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_7():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Top horizontal&#10;            img[5:8, 8:20] = 1&#10;            # Diagonal line going down-left&#10;            for i in range(15):&#10;                y = 8 + i&#10;                x = 17 - i//2&#10;                if 0 &lt;= y &lt; 28 and 0 &lt;= x &lt; 28:&#10;                    img[y:y+2, x:x+2] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_8():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Top circle&#10;            center_y, center_x = 9, 14&#10;            radius = 4&#10;            y, x = np.ogrid[:28, :28]&#10;            mask = (x - center_x)**2 + (y - center_y)**2 &lt;= radius**2&#10;            inner_mask = (x - center_x)**2 + (y - center_y)**2 &lt;= (radius - 2)**2&#10;            img[mask &amp; ~inner_mask] = 1&#10;            &#10;            # Bottom circle&#10;            center_y, center_x = 19, 14&#10;            mask = (x - center_x)**2 + (y - center_y)**2 &lt;= radius**2&#10;            inner_mask = (x - center_x)**2 + (y - center_y)**2 &lt;= (radius - 2)**2&#10;            img[mask &amp; ~inner_mask] = 1&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    def create_digit_9():&#10;        patterns = []&#10;        for _ in range(100):&#10;            img = np.zeros((28, 28))&#10;            # Similar to 6 but flipped&#10;            img[5:8, 8:18] = 1  # Top horizontal&#10;            img[5:14, 8:11] = 1  # Left vertical (top part)&#10;            img[5:14, 15:18] = 1  # Right vertical&#10;            img[12:15, 8:18] = 1  # Middle horizontal&#10;            img[15:23, 15:18] = 1  # Right vertical continues&#10;            img[20:23, 8:18] = 1  # Bottom horizontal&#10;            patterns.append(img)&#10;        return patterns&#10;&#10;    # Create all digits&#10;    all_data = []&#10;    all_labels = []&#10;    &#10;    digit_creators = [&#10;        create_digit_0, create_digit_1, create_digit_2, create_digit_3, create_digit_4,&#10;        create_digit_5, create_digit_6, create_digit_7, create_digit_8, create_digit_9&#10;    ]&#10;    &#10;    for digit, creator in enumerate(digit_creators):&#10;        patterns = creator()&#10;        for pattern in patterns:&#10;            # Add some noise and variation&#10;            pattern = ndimage.gaussian_filter(pattern, sigma=0.5)&#10;            pattern = pattern + np.random.normal(0, 0.1, pattern.shape)&#10;            pattern = np.clip(pattern, 0, 1)&#10;            &#10;            all_data.append(pattern)&#10;            all_labels.append(digit)&#10;    &#10;    return np.array(all_data), np.array(all_labels)&#10;&#10;&#10;def train_model():&#10;    &quot;&quot;&quot;Train the model on synthetic data&quot;&quot;&quot;&#10;    print(&quot;Creating synthetic training data...&quot;)&#10;    X_train, y_train = create_synthetic_mnist_data()&#10;    &#10;    # Convert to PyTorch tensors&#10;    X_train = torch.FloatTensor(X_train).unsqueeze(1)  # Add channel dimension&#10;    y_train = torch.LongTensor(y_train)&#10;    &#10;    # Create model&#10;    model = LeNet5()&#10;    criterion = nn.CrossEntropyLoss()&#10;    optimizer = optim.Adam(model.parameters(), lr=0.001)&#10;    &#10;    print(&quot;Training model...&quot;)&#10;    model.train()&#10;    &#10;    for epoch in range(50):&#10;        optimizer.zero_grad()&#10;        outputs = model(X_train)&#10;        loss = criterion(outputs, y_train)&#10;        loss.backward()&#10;        optimizer.step()&#10;        &#10;        if epoch % 10 == 0:&#10;            _, predicted = torch.max(outputs.data, 1)&#10;            accuracy = (predicted == y_train).float().mean()&#10;            print(f'Epoch {epoch}: Loss: {loss.item():.4f}, Accuracy: {accuracy:.4f}')&#10;    &#10;    # Save model&#10;    torch.save(model.state_dict(), 'digit_model.pth')&#10;    print(&quot;Model training completed and saved!&quot;)&#10;    return model&#10;&#10;&#10;def preprocess_drawn_image(image):&#10;    &quot;&quot;&quot;&#10;    Preprocess user-drawn image to match training data format&#10;    Based on successful preprocessing techniques from popular repositories&#10;    &quot;&quot;&quot;&#10;    # Convert PIL to numpy&#10;    img_array = np.array(image.convert('L'))&#10;    &#10;    # Invert if needed (make sure digit is white on black background)&#10;    if np.mean(img_array) &gt; 127:&#10;        img_array = 255 - img_array&#10;    &#10;    # Find bounding box&#10;    coords = np.column_stack(np.where(img_array &gt; 50))&#10;    if len(coords) == 0:&#10;        return None&#10;        &#10;    y_min, x_min = coords.min(axis=0)&#10;    y_max, x_max = coords.max(axis=0)&#10;    &#10;    # Add padding&#10;    padding = 20&#10;    y_min = max(0, y_min - padding)&#10;    y_max = min(img_array.shape[0], y_max + padding)&#10;    x_min = max(0, x_min - padding)&#10;    x_max = min(img_array.shape[1], x_max + padding)&#10;    &#10;    # Crop&#10;    cropped = img_array[y_min:y_max, x_min:x_max]&#10;    &#10;    # Resize to 28x28 with aspect ratio preservation&#10;    h, w = cropped.shape&#10;    size = max(h, w)&#10;    &#10;    # Create square image&#10;    square = np.zeros((size, size))&#10;    y_offset = (size - h) // 2&#10;    x_offset = (size - w) // 2&#10;    square[y_offset:y_offset + h, x_offset:x_offset + w] = cropped&#10;    &#10;    # Resize to 28x28&#10;    final_img = cv2.resize(square, (28, 28))&#10;    &#10;    # Normalize&#10;    final_img = final_img / 255.0&#10;    &#10;    # Apply slight blur to match training data&#10;    final_img = ndimage.gaussian_filter(final_img, sigma=0.5)&#10;    &#10;    return final_img&#10;&#10;&#10;class DigitRecognizerApp:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;Digit Recognizer - Clean Implementation&quot;)&#10;        self.root.geometry(&quot;800x600&quot;)&#10;        &#10;        # Load or train model&#10;        self.model = LeNet5()&#10;        if os.path.exists('digit_model.pth'):&#10;            self.model.load_state_dict(torch.load('digit_model.pth', map_location='cpu'))&#10;            print(&quot;Loaded existing model&quot;)&#10;        else:&#10;            print(&quot;Training new model...&quot;)&#10;            self.model = train_model()&#10;        &#10;        self.model.eval()&#10;        &#10;        # Setup canvas&#10;        self.canvas_size = 400&#10;        self.setup_ui()&#10;        self.drawing = False&#10;        &#10;    def setup_ui(self):&#10;        # Main frame&#10;        main_frame = ttk.Frame(self.root, padding=&quot;10&quot;)&#10;        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))&#10;        &#10;        # Title&#10;        title_label = ttk.Label(main_frame, text=&quot;Handwritten Digit Recognizer&quot;, &#10;                               font=('Arial', 20, 'bold'))&#10;        title_label.grid(row=0, column=0, columnspan=2, pady=10)&#10;        &#10;        # Instructions&#10;        instr_label = ttk.Label(main_frame, text=&quot;Draw a digit (0-9) in the canvas below:&quot;)&#10;        instr_label.grid(row=1, column=0, columnspan=2, pady=5)&#10;        &#10;        # Canvas&#10;        self.canvas = tk.Canvas(main_frame, width=self.canvas_size, height=self.canvas_size,&#10;                               bg='white', relief='solid', borderwidth=2)&#10;        self.canvas.grid(row=2, column=0, padx=10, pady=10)&#10;        &#10;        # Canvas events&#10;        self.canvas.bind('&lt;Button-1&gt;', self.start_drawing)&#10;        self.canvas.bind('&lt;B1-Motion&gt;', self.draw)&#10;        self.canvas.bind('&lt;ButtonRelease-1&gt;', self.stop_drawing)&#10;        &#10;        # Results frame&#10;        results_frame = ttk.Frame(main_frame)&#10;        results_frame.grid(row=2, column=1, padx=20, sticky=(tk.N, tk.S))&#10;        &#10;        # Prediction display&#10;        ttk.Label(results_frame, text=&quot;Prediction:&quot;, font=('Arial', 14, 'bold')).pack(pady=5)&#10;        &#10;        self.prediction_var = tk.StringVar(value=&quot;Draw a digit&quot;)&#10;        self.prediction_label = ttk.Label(results_frame, textvariable=self.prediction_var,&#10;                                         font=('Arial', 48, 'bold'), foreground='blue')&#10;        self.prediction_label.pack(pady=10)&#10;        &#10;        self.confidence_var = tk.StringVar(value=&quot;&quot;)&#10;        self.confidence_label = ttk.Label(results_frame, textvariable=self.confidence_var,&#10;                                         font=('Arial', 12))&#10;        self.confidence_label.pack(pady=5)&#10;        &#10;        # Buttons&#10;        button_frame = ttk.Frame(results_frame)&#10;        button_frame.pack(pady=20)&#10;        &#10;        ttk.Button(button_frame, text=&quot;Clear&quot;, command=self.clear_canvas).pack(pady=5, fill='x')&#10;        ttk.Button(button_frame, text=&quot;Predict&quot;, command=self.predict_digit).pack(pady=5, fill='x')&#10;        &#10;        # PIL Image for processing&#10;        self.image = Image.new('RGB', (self.canvas_size, self.canvas_size), 'white')&#10;        self.draw_obj = ImageDraw.Draw(self.image)&#10;        &#10;    def start_drawing(self, event):&#10;        self.drawing = True&#10;        self.last_x = event.x&#10;        self.last_y = event.y&#10;        &#10;    def draw(self, event):&#10;        if self.drawing:&#10;            # Draw on canvas&#10;            self.canvas.create_line(self.last_x, self.last_y, event.x, event.y,&#10;                                   width=8, fill='black', capstyle='round', smooth=True)&#10;            &#10;            # Draw on PIL image&#10;            self.draw_obj.line([self.last_x, self.last_y, event.x, event.y],&#10;                              fill='black', width=8)&#10;            &#10;            self.last_x = event.x&#10;            self.last_y = event.y&#10;            &#10;    def stop_drawing(self, event):&#10;        self.drawing = False&#10;        # Auto-predict after a short delay&#10;        self.root.after(300, self.predict_digit)&#10;        &#10;    def clear_canvas(self):&#10;        self.canvas.delete(&quot;all&quot;)&#10;        self.image = Image.new('RGB', (self.canvas_size, self.canvas_size), 'white')&#10;        self.draw_obj = ImageDraw.Draw(self.image)&#10;        self.prediction_var.set(&quot;Draw a digit&quot;)&#10;        self.confidence_var.set(&quot;&quot;)&#10;        &#10;    def predict_digit(self):&#10;        # Check if anything is drawn&#10;        if not self.canvas.find_all():&#10;            return&#10;            &#10;        # Preprocess image&#10;        processed = preprocess_drawn_image(self.image)&#10;        if processed is None:&#10;            return&#10;            &#10;        # Convert to tensor&#10;        input_tensor = torch.FloatTensor(processed).unsqueeze(0).unsqueeze(0)&#10;        &#10;        # Predict&#10;        with torch.no_grad():&#10;            outputs = self.model(input_tensor)&#10;            probabilities = F.softmax(outputs, dim=1)[0]&#10;            &#10;            # Get prediction and confidence&#10;            predicted_class = torch.argmax(outputs, dim=1).item()&#10;            confidence = probabilities[predicted_class].item() * 100&#10;            &#10;            # Update display&#10;            self.prediction_var.set(str(predicted_class))&#10;            self.confidence_var.set(f&quot;Confidence: {confidence:.1f}%&quot;)&#10;            &#10;            # Color code confidence&#10;            if confidence &gt; 80:&#10;                self.prediction_label.configure(foreground='green')&#10;            elif confidence &gt; 60:&#10;                self.prediction_label.configure(foreground='orange')&#10;            else:&#10;                self.prediction_label.configure(foreground='red')&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    root = tk.Tk()&#10;    app = DigitRecognizerApp(root)&#10;    root.mainloop()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fix_patterns.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fix_patterns.py" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#10;&quot;&quot;&quot;&#10;Script to fix the digit patterns to be exactly 28x28&#10;&quot;&quot;&quot;&#10;import numpy as np&#10;&#10;def create_fixed_digit_0_pattern():&#10;    &quot;&quot;&quot;Create a corrected 28x28 pattern for digit 0&quot;&quot;&quot;&#10;    return np.array([&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;        [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;        [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;        [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;        [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;        [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;    ])&#10;&#10;def create_fixed_digit_2_pattern():&#10;    &quot;&quot;&quot;Create a corrected 28x28 pattern for digit 2&quot;&quot;&quot;&#10;    return np.array([&#10;        [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],&#10;        [0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;        [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;    ])&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Test the patterns&#10;    pattern_0 = create_fixed_digit_0_pattern()&#10;    pattern_2 = create_fixed_digit_2_pattern()&#10;    &#10;    print(f&quot;Digit 0 pattern shape: {pattern_0.shape}&quot;)&#10;    print(f&quot;Digit 2 pattern shape: {pattern_2.shape}&quot;)&#10;    &#10;    # Verify they are 28x28&#10;    assert pattern_0.shape == (28, 28), f&quot;Expected (28, 28), got {pattern_0.shape}&quot;&#10;    assert pattern_2.shape == (28, 28), f&quot;Expected (28, 28), got {pattern_2.shape}&quot;&#10;    &#10;    print(&quot;✓ Both patterns are correctly sized at 28x28!&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/fixed_patterns.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/fixed_patterns.py" />
              <option name="updatedContent" value="import numpy as np&#10;&#10;def create_all_28x28_patterns():&#10;    &quot;&quot;&quot;Create all digit patterns as exactly 28x28 arrays&quot;&quot;&quot;&#10;    &#10;    # Digit 0 - Oval shape (28x28)&#10;    digit_0 = np.array([&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;        [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;        [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;        [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0],&#10;        [0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0],&#10;        [0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0],&#10;        [0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0],&#10;        [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;    ])&#10;&#10;    # Digit 1 - Straight line (28x28)&#10;    digit_1 = np.array([&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;    ])&#10;&#10;    # Digit 2 - S-curve (28x28)&#10;    digit_2 = np.array([&#10;        [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],&#10;        [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],&#10;        [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],&#10;        [0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;        [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],&#10;        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]&#10;    ])&#10;&#10;    return digit_0, digit_1, digit_2&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    d0, d1, d2 = create_all_28x28_patterns()&#10;    print(f&quot;Digit 0 shape: {d0.shape}&quot;)&#10;    print(f&quot;Digit 1 shape: {d1.shape}&quot;)&#10;    print(f&quot;Digit 2 shape: {d2.shape}&quot;)&#10;    &#10;    # Verify all are 28x28&#10;    assert d0.shape == (28, 28), f&quot;Digit 0: Expected (28, 28), got {d0.shape}&quot;&#10;    assert d1.shape == (28, 28), f&quot;Digit 1: Expected (28, 28), got {d1.shape}&quot;&#10;    assert d2.shape == (28, 28), f&quot;Digit 2: Expected (28, 28), got {d2.shape}&quot;&#10;    &#10;    print(&quot;✓ All patterns are correctly sized at 28x28!&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/main.py" />
              <option name="originalContent" value="import tkinter as tk&#10;import numpy as np&#10;from DigitRecognizer import DigitRecognizer&#10;&#10;&#10;class DigitRecognitionGUI:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;Handwritten Digit Recognition&quot;)&#10;        self.root.geometry(&quot;500x750&quot;)&#10;        self.root.configure(bg='lightgray')&#10;&#10;        # Canvas settings&#10;        self.canvas_size = 280&#10;        self.grid_size = 14  # 14x14 grid for pattern matching&#10;        self.cell_size = self.canvas_size // self.grid_size&#10;&#10;        # Drawing state&#10;        self.drawing = False&#10;        self.drawn_pixels = set()&#10;        self.last_prediction = None&#10;        self.last_drawn_array = None&#10;        self.feedback_given = False  # Track if feedback has been provided&#10;        self.feedback_type = None    # Track type of feedback ('positive' or 'negative')&#10;&#10;        # Undo functionality state&#10;        self.undo_available = False&#10;        self.last_action_data = None  # Store data needed to undo the last action&#10;&#10;        # Dropdown state for feedback&#10;        self.feedback_dropdown_open = False&#10;&#10;        # Initialize the digit recognizer&#10;        self.recognizer = DigitRecognizer()&#10;&#10;        # Create GUI elements&#10;        self.setup_gui()&#10;&#10;    def setup_gui(self):&#10;        # Title&#10;        title_label = tk.Label(self.root, text=&quot;Draw a Digit (0-9)&quot;,&#10;                              font=(&quot;Arial&quot;, 16, &quot;bold&quot;), bg='lightgray')&#10;        title_label.pack(pady=10)&#10;&#10;        # Canvas frame&#10;        canvas_frame = tk.Frame(self.root, bg='black', bd=2)&#10;        canvas_frame.pack(pady=10)&#10;&#10;        # Drawing canvas&#10;        self.canvas = tk.Canvas(canvas_frame, width=self.canvas_size, height=self.canvas_size,&#10;                               bg='white', cursor='pencil')&#10;        self.canvas.pack(padx=2, pady=2)&#10;&#10;        # Bind mouse events for drawing&#10;        self.canvas.bind(&quot;&lt;Button-1&gt;&quot;, self.start_drawing)&#10;        self.canvas.bind(&quot;&lt;B1-Motion&gt;&quot;, self.draw)&#10;        self.canvas.bind(&quot;&lt;ButtonRelease-1&gt;&quot;, self.stop_drawing)&#10;&#10;        # Buttons frame&#10;        button_frame = tk.Frame(self.root, bg='lightgray')&#10;        button_frame.pack(pady=10)&#10;&#10;        # Clear button&#10;        clear_btn = tk.Button(button_frame, text=&quot;Clear&quot;, command=self.clear_canvas,&#10;                             font=(&quot;Arial&quot;, 12), bg='lightcoral', width=15)&#10;        clear_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Predict button&#10;        predict_btn = tk.Button(button_frame, text=&quot;Predict&quot;, command=self.predict_digit,&#10;                               font=(&quot;Arial&quot;, 12), bg='lightgreen', width=15)&#10;        predict_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Prediction result frame&#10;        result_frame = tk.Frame(self.root, bg='white', bd=2, relief='solid')&#10;        result_frame.pack(pady=20, padx=50, fill='x')&#10;&#10;        # Prediction label&#10;        tk.Label(result_frame, text=&quot;Prediction:&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;                bg='white').pack(pady=5)&#10;&#10;        self.prediction_label = tk.Label(result_frame, text=&quot;Draw a digit and click Predict&quot;,&#10;                                        font=(&quot;Arial&quot;, 24, &quot;bold&quot;), bg='white', fg='blue')&#10;        self.prediction_label.pack(pady=10)&#10;&#10;        # Confidence label&#10;        self.confidence_label = tk.Label(result_frame, text=&quot;&quot;,&#10;                                        font=(&quot;Arial&quot;, 10), bg='white', fg='gray')&#10;        self.confidence_label.pack(pady=5)&#10;&#10;        # Feedback container frame (always visible when there's a prediction)&#10;        self.feedback_container = tk.Frame(result_frame, bg='white')&#10;&#10;        # Dropdown button for feedback (initially hidden)&#10;        self.dropdown_btn = tk.Button(self.feedback_container, text=&quot;▼ Feedback Options&quot;,&#10;                                     command=self.toggle_feedback_dropdown,&#10;                                     font=(&quot;Arial&quot;, 12), bg='lightblue', width=20)&#10;        self.dropdown_btn.pack(pady=5)&#10;&#10;        # Feedback frame (collapsible content - initially hidden)&#10;        self.feedback_frame = tk.Frame(self.feedback_container, bg='white')&#10;&#10;        # Feedback question&#10;        feedback_question = tk.Label(self.feedback_frame, text=&quot;Was this prediction correct?&quot;,&#10;                                   font=(&quot;Arial&quot;, 12), bg='white', fg='black')&#10;        feedback_question.pack(pady=(10, 5))&#10;&#10;        # Feedback buttons frame&#10;        feedback_buttons_frame = tk.Frame(self.feedback_frame, bg='white')&#10;        feedback_buttons_frame.pack(pady=5)&#10;&#10;        # Thumbs up button&#10;        self.thumbs_up_btn = tk.Button(feedback_buttons_frame, text=&quot; Correct&quot;,&#10;                                      command=self.positive_feedback,&#10;                                      font=(&quot;Arial&quot;, 12), bg='lightgreen',&#10;                                      width=12, relief='raised')&#10;        self.thumbs_up_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Thumbs down button&#10;        self.thumbs_down_btn = tk.Button(feedback_buttons_frame, text=&quot; Wrong&quot;,&#10;                                        command=self.negative_feedback,&#10;                                        font=(&quot;Arial&quot;, 12), bg='lightcoral',&#10;                                        width=12, relief='raised')&#10;        self.thumbs_down_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Undo button (initially hidden)&#10;        self.undo_btn = tk.Button(feedback_buttons_frame, text=&quot;↶ Undo&quot;,&#10;                                 command=self.undo_feedback,&#10;                                 font=(&quot;Arial&quot;, 12), bg='lightyellow',&#10;                                 width=12, relief='raised', state='disabled')&#10;        self.undo_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Feedback status label&#10;        self.feedback_status_label = tk.Label(self.feedback_frame, text=&quot;&quot;,&#10;                                             font=(&quot;Arial&quot;, 10), bg='white', fg='green')&#10;        self.feedback_status_label.pack(pady=5)&#10;&#10;        # Initially hide the feedback frame (dropdown content)&#10;        # Don't pack the feedback_frame yet - it will be shown/hidden by dropdown&#10;&#10;        # Don't pack the feedback_container yet - it will be shown when there's a prediction&#10;&#10;    def start_drawing(self, event):&#10;        self.drawing = True&#10;        self.draw(event)&#10;&#10;    def draw(self, event):&#10;        if self.drawing:&#10;            x, y = event.x, event.y&#10;            # Draw a small circle&#10;            radius = 8&#10;            self.canvas.create_oval(x-radius, y-radius, x+radius, y+radius,&#10;                                   fill='black', outline='black')&#10;&#10;            # Store drawn pixels for pattern matching&#10;            grid_x = min(x // self.cell_size, self.grid_size - 1)&#10;            grid_y = min(y // self.cell_size, self.grid_size - 1)&#10;            self.drawn_pixels.add((grid_x, grid_y))&#10;&#10;    def stop_drawing(self, event):&#10;        self.drawing = False&#10;&#10;    def clear_canvas(self):&#10;        self.canvas.delete(&quot;all&quot;)&#10;        self.drawn_pixels.clear()&#10;        self.prediction_label.config(text=&quot;Draw a digit and click Predict&quot;)&#10;        self.confidence_label.config(text=&quot;&quot;)&#10;        self.hide_feedback_buttons()&#10;        self.last_prediction = None&#10;        self.last_drawn_array = None&#10;        self.reset_feedback_state()  # Reset feedback state when clearing&#10;&#10;    def reset_feedback_state(self):&#10;        &quot;&quot;&quot;Reset feedback state for new drawing&quot;&quot;&quot;&#10;        self.feedback_given = False&#10;        self.feedback_type = None&#10;        self.undo_available = False&#10;        self.last_action_data = None&#10;        # Reset button appearance&#10;        self.thumbs_up_btn.config(bg='lightgreen', state='normal', relief='raised')&#10;        self.thumbs_down_btn.config(bg='lightcoral', state='normal', relief='raised')&#10;        self.undo_btn.config(state='disabled', bg='lightgray')&#10;&#10;    def get_drawing_array(self):&#10;        &quot;&quot;&quot;Convert drawing to 14x14 binary array&quot;&quot;&quot;&#10;        array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;        for x, y in self.drawn_pixels:&#10;            array[y, x] = 1&#10;        return array&#10;&#10;    def predict_digit(self):&#10;        &quot;&quot;&quot;Predict the digit based on the drawing with comprehensive error handling&quot;&quot;&quot;&#10;        try:&#10;            # Check if canvas is empty&#10;            if not self.drawn_pixels:&#10;                self.prediction_label.config(text=&quot;����� Canvas is empty!&quot;, fg='red')&#10;                self.confidence_label.config(text=&quot;Please draw a digit first&quot;)&#10;                self.hide_feedback_buttons()&#10;                return&#10;&#10;            # Check if drawing is too small (less than 3 pixels)&#10;            if len(self.drawn_pixels) &lt; 3:&#10;                self.prediction_label.config(text=&quot;❌ Drawing too small!&quot;, fg='red')&#10;                self.confidence_label.config(text=&quot;Please draw a larger digit&quot;)&#10;                self.hide_feedback_buttons()&#10;                return&#10;&#10;            drawn_array = self.get_drawing_array()&#10;            self.last_drawn_array = drawn_array&#10;&#10;            # Use the recognizer to predict&#10;            best_digit, best_similarity, similarities = self.recognizer.predict_digit(drawn_array)&#10;&#10;            # Store the prediction for feedback&#10;            self.last_prediction = best_digit&#10;&#10;            # Display result with better error handling&#10;            if best_digit is not None and best_similarity &gt; 0.05:  # Lowered threshold for better detection&#10;                self.prediction_label.config(text=f&quot;Predicted Digit: {best_digit}&quot;, fg='blue')&#10;                confidence_percent = min(int(best_similarity * 100), 99)  # Cap at 99%&#10;                self.confidence_label.config(text=f&quot;Confidence: {confidence_percent}%&quot;, fg='gray')&#10;&#10;                # Show feedback buttons only for valid predictions&#10;                self.show_feedback_buttons()&#10;            else:&#10;                self.prediction_label.config(text=&quot;❌ Unable to recognize digit&quot;, fg='red')&#10;                self.confidence_label.config(text=&quot;Try drawing more clearly or a different style&quot;, fg='gray')&#10;                self.hide_feedback_buttons()&#10;&#10;        except Exception as e:&#10;            # Catch any unexpected errors&#10;            self.prediction_label.config(text=&quot;❌ Error during prediction&quot;, fg='red')&#10;            self.confidence_label.config(text=f&quot;Error: {str(e)}&quot;, fg='gray')&#10;            self.hide_feedback_buttons()&#10;            print(f&quot;Prediction error: {e}&quot;)&#10;&#10;    def positive_feedback(self):&#10;        &quot;&quot;&quot;Handle positive feedback with error handling and prevent duplicate submissions&quot;&quot;&quot;&#10;        try:&#10;            # Check if feedback has already been given&#10;            if self.feedback_given:&#10;                self.feedback_status_label.config(&#10;                    text=f&quot;⚠️ Feedback already submitted ({self.feedback_type})&quot;, &#10;                    fg='orange'&#10;                )&#10;                return&#10;            &#10;            if self.last_prediction is not None and self.last_drawn_array is not None:&#10;                # Store action data for undo before making changes&#10;                self.last_action_data = {&#10;                    'action_type': 'positive_feedback',&#10;                    'digit': self.last_prediction,&#10;                    'pattern_added': self.last_drawn_array.tolist(),&#10;                }&#10;&#10;                # Add the feedback to the recognizer&#10;                success = self.recognizer.add_positive_feedback(self.last_drawn_array, self.last_prediction)&#10;&#10;                if success:&#10;                    learned_count = self.recognizer.get_pattern_count(self.last_prediction)&#10;                    self.feedback_status_label.config(&#10;                        text=f&quot;✓ Saved! Now have {learned_count} examples of digit {self.last_prediction}&quot;,&#10;                        fg='green'&#10;                    )&#10;&#10;                    # Update feedback state and button appearance&#10;                    self.feedback_given = True&#10;                    self.feedback_type = 'positive'&#10;                    self.undo_available = True&#10;                    self.update_feedback_buttons()&#10;&#10;                    # Save to file with error handling&#10;                    if not self.recognizer.save_learned_patterns():&#10;                        self.feedback_status_label.config(&#10;                            text=&quot;❌ Error saving pattern&quot;,&#10;                            fg='red'&#10;                        )&#10;                else:&#10;                    self.feedback_status_label.config(text=&quot;❌ Error adding positive feedback&quot;, fg='red')&#10;            else:&#10;                self.feedback_status_label.config(text=&quot;❌ No prediction to confirm.&quot;, fg='red')&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Error: {str(e)}&quot;, fg='red')&#10;            print(f&quot;Positive feedback error: {e}&quot;)&#10;&#10;    def negative_feedback(self):&#10;        &quot;&quot;&quot;Handle negative feedback - ask user for correct digit&quot;&quot;&quot;&#10;        try:&#10;            # Check if feedback has already been given&#10;            if self.feedback_given:&#10;                self.feedback_status_label.config(&#10;                    text=f&quot;⚠️ Feedback already submitted ({self.feedback_type})&quot;,&#10;                    fg='orange'&#10;                )&#10;                return&#10;&#10;            if self.last_prediction is not None and self.last_drawn_array is not None:&#10;                # Create a dialog to ask for the correct digit&#10;                self.create_correction_dialog()&#10;            else:&#10;                self.feedback_status_label.config(text=&quot;❌ No prediction to correct.&quot;, fg='red')&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Error: {str(e)}&quot;, fg='red')&#10;&#10;    def create_correction_dialog(self):&#10;        &quot;&quot;&quot;Create a dialog for the user to input the correct digit&quot;&quot;&quot;&#10;        dialog = tk.Toplevel(self.root)&#10;        dialog.title(&quot;Correct the Prediction&quot;)&#10;        dialog.geometry(&quot;400x300&quot;)&#10;        dialog.configure(bg='lightgray')&#10;        dialog.transient(self.root)&#10;        dialog.grab_set()&#10;&#10;        # Center the dialog&#10;        dialog.update_idletasks()&#10;        x = (dialog.winfo_screenwidth() // 2) - (dialog.winfo_width() // 2)&#10;        y = (dialog.winfo_screenheight() // 2) - (dialog.winfo_height() // 2)&#10;        dialog.geometry(f&quot;+{x}+{y}&quot;)&#10;&#10;        # Instructions&#10;        tk.Label(dialog, text=f&quot;The prediction was: {self.last_prediction}&quot;,&#10;                font=(&quot;Arial&quot;, 12), bg='lightgray').pack(pady=10)&#10;        tk.Label(dialog, text=&quot;What is the correct digit?&quot;,&#10;                font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='lightgray').pack(pady=5)&#10;&#10;        # Digit selection frame&#10;        digit_frame = tk.Frame(dialog, bg='lightgray')&#10;        digit_frame.pack(pady=15)&#10;&#10;        # Create buttons for digits 0-9&#10;        for i in range(10):&#10;            btn = tk.Button(digit_frame, text=str(i), font=(&quot;Arial&quot;, 14, &quot;bold&quot;),&#10;                           width=4, height=2, command=lambda d=i: self.correct_prediction(d, dialog))&#10;            btn.grid(row=i//5, column=i%5, padx=8, pady=8)&#10;&#10;        # Cancel button&#10;        cancel_btn = tk.Button(dialog, text=&quot;Cancel&quot;, command=dialog.destroy,&#10;                              font=(&quot;Arial&quot;, 12), bg='lightcoral', width=12)&#10;        cancel_btn.pack(pady=20)&#10;&#10;    def correct_prediction(self, correct_digit, dialog):&#10;        &quot;&quot;&quot;Save the corrected prediction as a learned pattern&quot;&quot;&quot;&#10;        try:&#10;            # Store action data for undo before making changes&#10;            self.last_action_data = {&#10;                'action_type': 'negative_feedback',&#10;                'digit': correct_digit,&#10;                'pattern_added': self.last_drawn_array.tolist(),&#10;                'corrected_from': self.last_prediction,&#10;            }&#10;&#10;            # Add the correction to the recognizer&#10;            success = self.recognizer.add_negative_feedback(&#10;                self.last_drawn_array, self.last_prediction, correct_digit&#10;            )&#10;&#10;            if success:&#10;                learned_count = self.recognizer.get_pattern_count(correct_digit)&#10;                self.feedback_status_label.config(&#10;                    text=f&quot;✓ Corrected! Saved as digit {correct_digit}. Now have {learned_count} examples.&quot;,&#10;                    fg='green'&#10;                )&#10;&#10;                # Update feedback state&#10;                self.feedback_given = True&#10;                self.feedback_type = 'negative'&#10;                self.undo_available = True&#10;                self.update_feedback_buttons()&#10;&#10;                # Save to file&#10;                if not self.recognizer.save_learned_patterns():&#10;                    self.feedback_status_label.config(&#10;                        text=&quot;❌ Error saving correction&quot;,&#10;                        fg='red'&#10;                    )&#10;            else:&#10;                self.feedback_status_label.config(text=&quot;❌ Error adding correction&quot;, fg='red')&#10;&#10;            dialog.destroy()&#10;&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Error: {str(e)}&quot;, fg='red')&#10;            dialog.destroy()&#10;&#10;    def update_feedback_buttons(self):&#10;        &quot;&quot;&quot;Update the appearance of feedback buttons based on feedback state&quot;&quot;&quot;&#10;        if self.feedback_given:&#10;            if self.feedback_type == 'positive':&#10;                self.thumbs_up_btn.config(bg='darkgreen', state='disabled', relief='sunken')&#10;                self.thumbs_down_btn.config(bg='lightgray', state='disabled', relief='flat')&#10;            elif self.feedback_type == 'negative':&#10;                self.thumbs_up_btn.config(bg='lightgray', state='disabled', relief='flat')&#10;                self.thumbs_down_btn.config(bg='darkred', state='disabled', relief='sunken')&#10;&#10;            # Enable undo button when feedback is given&#10;            if self.undo_available:&#10;                self.undo_btn.config(state='normal', bg='lightyellow')&#10;        else:&#10;            # Reset to normal state&#10;            self.thumbs_up_btn.config(bg='lightgreen', state='normal', relief='raised')&#10;            self.thumbs_down_btn.config(bg='lightcoral', state='normal', relief='raised')&#10;            self.undo_btn.config(state='disabled', bg='lightgray')&#10;&#10;    def show_feedback_buttons(self):&#10;        &quot;&quot;&quot;Show the feedback dropdown button and reset feedback state&quot;&quot;&quot;&#10;        self.reset_feedback_state()&#10;        # Reset dropdown state&#10;        self.feedback_dropdown_open = False&#10;        self.dropdown_btn.config(text=&quot;▼ Feedback Options&quot;)&#10;        # Make sure the dropdown content is hidden initially&#10;        self.feedback_frame.pack_forget()&#10;        # Show the feedback container (which contains the dropdown button)&#10;        self.feedback_container.pack(pady=10)&#10;&#10;    def hide_feedback_buttons(self):&#10;        &quot;&quot;&quot;Hide the entire feedback section&quot;&quot;&quot;&#10;        # Hide the entire feedback container&#10;        self.feedback_container.pack_forget()&#10;        # Also hide the dropdown content if it was open&#10;        self.feedback_frame.pack_forget()&#10;        # Reset dropdown state&#10;        self.feedback_dropdown_open = False&#10;        self.reset_feedback_state()&#10;&#10;    def toggle_feedback_dropdown(self):&#10;        &quot;&quot;&quot;Toggle the feedback dropdown menu&quot;&quot;&quot;&#10;        if self.feedback_dropdown_open:&#10;            # Close the dropdown&#10;            self.feedback_frame.pack_forget()&#10;            self.feedback_dropdown_open = False&#10;            self.dropdown_btn.config(text=&quot;▼ Feedback Options&quot;)&#10;        else:&#10;            # Open the dropdown&#10;            self.feedback_frame.pack(pady=10)&#10;            self.feedback_dropdown_open = True&#10;            self.dropdown_btn.config(text=&quot;▲ Feedback Options&quot;)&#10;&#10;    def undo_feedback(self):&#10;        &quot;&quot;&quot;Undo the last feedback action&quot;&quot;&quot;&#10;        try:&#10;            if not self.undo_available or not self.last_action_data:&#10;                self.feedback_status_label.config(text=&quot;❌ No action to undo.&quot;, fg='red')&#10;                return&#10;&#10;            action_data = self.last_action_data&#10;            action_type = action_data.get('action_type')&#10;            digit = action_data.get('digit')&#10;&#10;            if action_type == 'positive_feedback':&#10;                # Remove the pattern that was added for positive feedback&#10;                success = self.recognizer.remove_last_pattern(digit)&#10;                if success:&#10;                    self.feedback_status_label.config(&#10;                        text=f&quot;↶ Undone! Removed pattern for digit {digit}&quot;,&#10;                        fg='blue'&#10;                    )&#10;                else:&#10;                    self.feedback_status_label.config(&#10;                        text=&quot;❌ Error: Pattern not found to undo&quot;,&#10;                        fg='red'&#10;                    )&#10;&#10;            elif action_type == 'negative_feedback':&#10;                # Remove the pattern that was added for the corrected digit&#10;                success = self.recognizer.remove_last_pattern(digit)&#10;                if success:&#10;                    corrected_from = action_data.get('corrected_from', 'unknown')&#10;                    self.feedback_status_label.config(&#10;                        text=f&quot;↶ Undone! Removed correction from {corrected_from} to {digit}&quot;,&#10;                        fg='blue'&#10;                    )&#10;                else:&#10;                    self.feedback_status_label.config(&#10;                        text=&quot;❌ Error: Correction not found to undo&quot;,&#10;                        fg='red'&#10;                    )&#10;&#10;            # Reset feedback state&#10;            self.feedback_given = False&#10;            self.feedback_type = None&#10;            self.undo_available = False&#10;            self.last_action_data = None&#10;&#10;            # Update button appearances&#10;            self.update_feedback_buttons()&#10;&#10;            # Save the changes to file&#10;            if not self.recognizer.save_learned_patterns():&#10;                self.feedback_status_label.config(&#10;                    text=&quot;❌ Error saving after undo&quot;,&#10;                    fg='red'&#10;                )&#10;&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Undo error: {str(e)}&quot;, fg='red')&#10;            print(f&quot;Undo error: {e}&quot;)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to run the application&quot;&quot;&quot;&#10;    root = tk.Tk()&#10;    app = DigitRecognitionGUI(root)&#10;&#10;    # Handle window closing gracefully&#10;    def on_closing():&#10;        try:&#10;            app.recognizer.save_learned_patterns()&#10;        except Exception as e:&#10;            print(f&quot;Error saving on exit: {e}&quot;)&#10;        root.destroy()&#10;&#10;    root.protocol(&quot;WM_DELETE_WINDOW&quot;, on_closing)&#10;    root.mainloop()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()&#10;" />
              <option name="updatedContent" value="import tkinter as tk&#10;import numpy as np&#10;from DigitRecognizer import DigitRecognizer&#10;&#10;&#10;class DigitRecognitionGUI:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;Handwritten Digit Recognition&quot;)&#10;        self.root.geometry(&quot;500x750&quot;)&#10;        self.root.configure(bg='lightgray')&#10;&#10;        # Canvas settings&#10;        self.canvas_size = 280&#10;        self.grid_size = 28  # 28x28 grid for pattern matching&#10;        self.cell_size = self.canvas_size // self.grid_size&#10;&#10;        # Drawing state&#10;        self.drawing = False&#10;        self.drawn_pixels = set()&#10;        self.last_prediction = None&#10;        self.last_drawn_array = None&#10;        self.feedback_given = False  # Track if feedback has been provided&#10;        self.feedback_type = None    # Track type of feedback ('positive' or 'negative')&#10;&#10;        # Undo functionality state&#10;        self.undo_available = False&#10;        self.last_action_data = None  # Store data needed to undo the last action&#10;&#10;        # Dropdown state for feedback&#10;        self.feedback_dropdown_open = False&#10;&#10;        # Initialize the digit recognizer&#10;        self.recognizer = DigitRecognizer()&#10;&#10;        # Create GUI elements&#10;        self.setup_gui()&#10;&#10;    def setup_gui(self):&#10;        # Title&#10;        title_label = tk.Label(self.root, text=&quot;Draw a Digit (0-9)&quot;,&#10;                              font=(&quot;Arial&quot;, 16, &quot;bold&quot;), bg='lightgray')&#10;        title_label.pack(pady=10)&#10;&#10;        # Canvas frame&#10;        canvas_frame = tk.Frame(self.root, bg='black', bd=2)&#10;        canvas_frame.pack(pady=10)&#10;&#10;        # Drawing canvas&#10;        self.canvas = tk.Canvas(canvas_frame, width=self.canvas_size, height=self.canvas_size,&#10;                               bg='white', cursor='pencil')&#10;        self.canvas.pack(padx=2, pady=2)&#10;&#10;        # Bind mouse events for drawing&#10;        self.canvas.bind(&quot;&lt;Button-1&gt;&quot;, self.start_drawing)&#10;        self.canvas.bind(&quot;&lt;B1-Motion&gt;&quot;, self.draw)&#10;        self.canvas.bind(&quot;&lt;ButtonRelease-1&gt;&quot;, self.stop_drawing)&#10;&#10;        # Buttons frame&#10;        button_frame = tk.Frame(self.root, bg='lightgray')&#10;        button_frame.pack(pady=10)&#10;&#10;        # Clear button&#10;        clear_btn = tk.Button(button_frame, text=&quot;Clear&quot;, command=self.clear_canvas,&#10;                             font=(&quot;Arial&quot;, 12), bg='lightcoral', width=15)&#10;        clear_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Predict button&#10;        predict_btn = tk.Button(button_frame, text=&quot;Predict&quot;, command=self.predict_digit,&#10;                               font=(&quot;Arial&quot;, 12), bg='lightgreen', width=15)&#10;        predict_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Prediction result frame&#10;        result_frame = tk.Frame(self.root, bg='white', bd=2, relief='solid')&#10;        result_frame.pack(pady=20, padx=50, fill='x')&#10;&#10;        # Prediction label&#10;        tk.Label(result_frame, text=&quot;Prediction:&quot;, font=(&quot;Arial&quot;, 12, &quot;bold&quot;),&#10;                bg='white').pack(pady=5)&#10;&#10;        self.prediction_label = tk.Label(result_frame, text=&quot;Draw a digit and click Predict&quot;,&#10;                                        font=(&quot;Arial&quot;, 24, &quot;bold&quot;), bg='white', fg='blue')&#10;        self.prediction_label.pack(pady=10)&#10;&#10;        # Confidence label&#10;        self.confidence_label = tk.Label(result_frame, text=&quot;&quot;,&#10;                                        font=(&quot;Arial&quot;, 10), bg='white', fg='gray')&#10;        self.confidence_label.pack(pady=5)&#10;&#10;        # Feedback container frame (always visible when there's a prediction)&#10;        self.feedback_container = tk.Frame(result_frame, bg='white')&#10;&#10;        # Dropdown button for feedback (initially hidden)&#10;        self.dropdown_btn = tk.Button(self.feedback_container, text=&quot;▼ Feedback Options&quot;,&#10;                                     command=self.toggle_feedback_dropdown,&#10;                                     font=(&quot;Arial&quot;, 12), bg='lightblue', width=20)&#10;        self.dropdown_btn.pack(pady=5)&#10;&#10;        # Feedback frame (collapsible content - initially hidden)&#10;        self.feedback_frame = tk.Frame(self.feedback_container, bg='white')&#10;&#10;        # Feedback question&#10;        feedback_question = tk.Label(self.feedback_frame, text=&quot;Was this prediction correct?&quot;,&#10;                                   font=(&quot;Arial&quot;, 12), bg='white', fg='black')&#10;        feedback_question.pack(pady=(10, 5))&#10;&#10;        # Feedback buttons frame&#10;        feedback_buttons_frame = tk.Frame(self.feedback_frame, bg='white')&#10;        feedback_buttons_frame.pack(pady=5)&#10;&#10;        # Thumbs up button&#10;        self.thumbs_up_btn = tk.Button(feedback_buttons_frame, text=&quot; Correct&quot;,&#10;                                      command=self.positive_feedback,&#10;                                      font=(&quot;Arial&quot;, 12), bg='lightgreen',&#10;                                      width=12, relief='raised')&#10;        self.thumbs_up_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Thumbs down button&#10;        self.thumbs_down_btn = tk.Button(feedback_buttons_frame, text=&quot; Wrong&quot;,&#10;                                        command=self.negative_feedback,&#10;                                        font=(&quot;Arial&quot;, 12), bg='lightcoral',&#10;                                        width=12, relief='raised')&#10;        self.thumbs_down_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Undo button (initially hidden)&#10;        self.undo_btn = tk.Button(feedback_buttons_frame, text=&quot;↶ Undo&quot;,&#10;                                 command=self.undo_feedback,&#10;                                 font=(&quot;Arial&quot;, 12), bg='lightyellow',&#10;                                 width=12, relief='raised', state='disabled')&#10;        self.undo_btn.pack(side=&quot;left&quot;, padx=10)&#10;&#10;        # Feedback status label&#10;        self.feedback_status_label = tk.Label(self.feedback_frame, text=&quot;&quot;,&#10;                                             font=(&quot;Arial&quot;, 10), bg='white', fg='green')&#10;        self.feedback_status_label.pack(pady=5)&#10;&#10;        # Initially hide the feedback frame (dropdown content)&#10;        # Don't pack the feedback_frame yet - it will be shown/hidden by dropdown&#10;&#10;        # Don't pack the feedback_container yet - it will be shown when there's a prediction&#10;&#10;    def start_drawing(self, event):&#10;        self.drawing = True&#10;        self.draw(event)&#10;&#10;    def draw(self, event):&#10;        if self.drawing:&#10;            x, y = event.x, event.y&#10;            # Draw a small circle&#10;            radius = 8&#10;            self.canvas.create_oval(x-radius, y-radius, x+radius, y+radius,&#10;                                   fill='black', outline='black')&#10;&#10;            # Store drawn pixels for pattern matching&#10;            grid_x = min(x // self.cell_size, self.grid_size - 1)&#10;            grid_y = min(y // self.cell_size, self.grid_size - 1)&#10;            self.drawn_pixels.add((grid_x, grid_y))&#10;&#10;    def stop_drawing(self, event):&#10;        self.drawing = False&#10;&#10;    def clear_canvas(self):&#10;        self.canvas.delete(&quot;all&quot;)&#10;        self.drawn_pixels.clear()&#10;        self.prediction_label.config(text=&quot;Draw a digit and click Predict&quot;)&#10;        self.confidence_label.config(text=&quot;&quot;)&#10;        self.hide_feedback_buttons()&#10;        self.last_prediction = None&#10;        self.last_drawn_array = None&#10;        self.reset_feedback_state()  # Reset feedback state when clearing&#10;&#10;    def reset_feedback_state(self):&#10;        &quot;&quot;&quot;Reset feedback state for new drawing&quot;&quot;&quot;&#10;        self.feedback_given = False&#10;        self.feedback_type = None&#10;        self.undo_available = False&#10;        self.last_action_data = None&#10;        # Reset button appearance&#10;        self.thumbs_up_btn.config(bg='lightgreen', state='normal', relief='raised')&#10;        self.thumbs_down_btn.config(bg='lightcoral', state='normal', relief='raised')&#10;        self.undo_btn.config(state='disabled', bg='lightgray')&#10;&#10;    def get_drawing_array(self):&#10;        &quot;&quot;&quot;Convert drawing to 28x28 binary array&quot;&quot;&quot;&#10;        array = np.zeros((self.grid_size, self.grid_size), dtype=int)&#10;        for x, y in self.drawn_pixels:&#10;            array[y, x] = 1&#10;        return array&#10;&#10;    def predict_digit(self):&#10;        &quot;&quot;&quot;Predict the digit based on the drawing with comprehensive error handling&quot;&quot;&quot;&#10;        try:&#10;            # Check if canvas is empty&#10;            if not self.drawn_pixels:&#10;                self.prediction_label.config(text=&quot;����� Canvas is empty!&quot;, fg='red')&#10;                self.confidence_label.config(text=&quot;Please draw a digit first&quot;)&#10;                self.hide_feedback_buttons()&#10;                return&#10;&#10;            # Check if drawing is too small (less than 3 pixels)&#10;            if len(self.drawn_pixels) &lt; 3:&#10;                self.prediction_label.config(text=&quot;❌ Drawing too small!&quot;, fg='red')&#10;                self.confidence_label.config(text=&quot;Please draw a larger digit&quot;)&#10;                self.hide_feedback_buttons()&#10;                return&#10;&#10;            drawn_array = self.get_drawing_array()&#10;            self.last_drawn_array = drawn_array&#10;&#10;            # Use the recognizer to predict&#10;            best_digit, best_similarity, similarities = self.recognizer.predict_digit(drawn_array)&#10;&#10;            # Store the prediction for feedback&#10;            self.last_prediction = best_digit&#10;&#10;            # Display result with better error handling&#10;            if best_digit is not None and best_similarity &gt; 0.05:  # Lowered threshold for better detection&#10;                self.prediction_label.config(text=f&quot;Predicted Digit: {best_digit}&quot;, fg='blue')&#10;                confidence_percent = min(int(best_similarity * 100), 99)  # Cap at 99%&#10;                self.confidence_label.config(text=f&quot;Confidence: {confidence_percent}%&quot;, fg='gray')&#10;&#10;                # Show feedback buttons only for valid predictions&#10;                self.show_feedback_buttons()&#10;            else:&#10;                self.prediction_label.config(text=&quot;❌ Unable to recognize digit&quot;, fg='red')&#10;                self.confidence_label.config(text=&quot;Try drawing more clearly or a different style&quot;, fg='gray')&#10;                self.hide_feedback_buttons()&#10;&#10;        except Exception as e:&#10;            # Catch any unexpected errors&#10;            self.prediction_label.config(text=&quot;❌ Error during prediction&quot;, fg='red')&#10;            self.confidence_label.config(text=f&quot;Error: {str(e)}&quot;, fg='gray')&#10;            self.hide_feedback_buttons()&#10;            print(f&quot;Prediction error: {e}&quot;)&#10;&#10;    def positive_feedback(self):&#10;        &quot;&quot;&quot;Handle positive feedback with error handling and prevent duplicate submissions&quot;&quot;&quot;&#10;        try:&#10;            # Check if feedback has already been given&#10;            if self.feedback_given:&#10;                self.feedback_status_label.config(&#10;                    text=f&quot;⚠️ Feedback already submitted ({self.feedback_type})&quot;, &#10;                    fg='orange'&#10;                )&#10;                return&#10;            &#10;            if self.last_prediction is not None and self.last_drawn_array is not None:&#10;                # Store action data for undo before making changes&#10;                self.last_action_data = {&#10;                    'action_type': 'positive_feedback',&#10;                    'digit': self.last_prediction,&#10;                    'pattern_added': self.last_drawn_array.tolist(),&#10;                }&#10;&#10;                # Add the feedback to the recognizer&#10;                success = self.recognizer.add_positive_feedback(self.last_drawn_array, self.last_prediction)&#10;&#10;                if success:&#10;                    learned_count = self.recognizer.get_pattern_count(self.last_prediction)&#10;                    self.feedback_status_label.config(&#10;                        text=f&quot;✓ Saved! Now have {learned_count} examples of digit {self.last_prediction}&quot;,&#10;                        fg='green'&#10;                    )&#10;&#10;                    # Update feedback state and button appearance&#10;                    self.feedback_given = True&#10;                    self.feedback_type = 'positive'&#10;                    self.undo_available = True&#10;                    self.update_feedback_buttons()&#10;&#10;                    # Save to file with error handling&#10;                    if not self.recognizer.save_learned_patterns():&#10;                        self.feedback_status_label.config(&#10;                            text=&quot;❌ Error saving pattern&quot;,&#10;                            fg='red'&#10;                        )&#10;                else:&#10;                    self.feedback_status_label.config(text=&quot;❌ Error adding positive feedback&quot;, fg='red')&#10;            else:&#10;                self.feedback_status_label.config(text=&quot;❌ No prediction to confirm.&quot;, fg='red')&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Error: {str(e)}&quot;, fg='red')&#10;            print(f&quot;Positive feedback error: {e}&quot;)&#10;&#10;    def negative_feedback(self):&#10;        &quot;&quot;&quot;Handle negative feedback - ask user for correct digit&quot;&quot;&quot;&#10;        try:&#10;            # Check if feedback has already been given&#10;            if self.feedback_given:&#10;                self.feedback_status_label.config(&#10;                    text=f&quot;⚠️ Feedback already submitted ({self.feedback_type})&quot;,&#10;                    fg='orange'&#10;                )&#10;                return&#10;&#10;            if self.last_prediction is not None and self.last_drawn_array is not None:&#10;                # Create a dialog to ask for the correct digit&#10;                self.create_correction_dialog()&#10;            else:&#10;                self.feedback_status_label.config(text=&quot;❌ No prediction to correct.&quot;, fg='red')&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Error: {str(e)}&quot;, fg='red')&#10;&#10;    def create_correction_dialog(self):&#10;        &quot;&quot;&quot;Create a dialog for the user to input the correct digit&quot;&quot;&quot;&#10;        dialog = tk.Toplevel(self.root)&#10;        dialog.title(&quot;Correct the Prediction&quot;)&#10;        dialog.geometry(&quot;400x300&quot;)&#10;        dialog.configure(bg='lightgray')&#10;        dialog.transient(self.root)&#10;        dialog.grab_set()&#10;&#10;        # Center the dialog&#10;        dialog.update_idletasks()&#10;        x = (dialog.winfo_screenwidth() // 2) - (dialog.winfo_width() // 2)&#10;        y = (dialog.winfo_screenheight() // 2) - (dialog.winfo_height() // 2)&#10;        dialog.geometry(f&quot;+{x}+{y}&quot;)&#10;&#10;        # Instructions&#10;        tk.Label(dialog, text=f&quot;The prediction was: {self.last_prediction}&quot;,&#10;                font=(&quot;Arial&quot;, 12), bg='lightgray').pack(pady=10)&#10;        tk.Label(dialog, text=&quot;What is the correct digit?&quot;,&#10;                font=(&quot;Arial&quot;, 12, &quot;bold&quot;), bg='lightgray').pack(pady=5)&#10;&#10;        # Digit selection frame&#10;        digit_frame = tk.Frame(dialog, bg='lightgray')&#10;        digit_frame.pack(pady=15)&#10;&#10;        # Create buttons for digits 0-9&#10;        for i in range(10):&#10;            btn = tk.Button(digit_frame, text=str(i), font=(&quot;Arial&quot;, 14, &quot;bold&quot;),&#10;                           width=4, height=2, command=lambda d=i: self.correct_prediction(d, dialog))&#10;            btn.grid(row=i//5, column=i%5, padx=8, pady=8)&#10;&#10;        # Cancel button&#10;        cancel_btn = tk.Button(dialog, text=&quot;Cancel&quot;, command=dialog.destroy,&#10;                              font=(&quot;Arial&quot;, 12), bg='lightcoral', width=12)&#10;        cancel_btn.pack(pady=20)&#10;&#10;    def correct_prediction(self, correct_digit, dialog):&#10;        &quot;&quot;&quot;Save the corrected prediction as a learned pattern&quot;&quot;&quot;&#10;        try:&#10;            # Store action data for undo before making changes&#10;            self.last_action_data = {&#10;                'action_type': 'negative_feedback',&#10;                'digit': correct_digit,&#10;                'pattern_added': self.last_drawn_array.tolist(),&#10;                'corrected_from': self.last_prediction,&#10;            }&#10;&#10;            # Add the correction to the recognizer&#10;            success = self.recognizer.add_negative_feedback(&#10;                self.last_drawn_array, self.last_prediction, correct_digit&#10;            )&#10;&#10;            if success:&#10;                learned_count = self.recognizer.get_pattern_count(correct_digit)&#10;                self.feedback_status_label.config(&#10;                    text=f&quot;✓ Corrected! Saved as digit {correct_digit}. Now have {learned_count} examples.&quot;,&#10;                    fg='green'&#10;                )&#10;&#10;                # Update feedback state&#10;                self.feedback_given = True&#10;                self.feedback_type = 'negative'&#10;                self.undo_available = True&#10;                self.update_feedback_buttons()&#10;&#10;                # Save to file&#10;                if not self.recognizer.save_learned_patterns():&#10;                    self.feedback_status_label.config(&#10;                        text=&quot;❌ Error saving correction&quot;,&#10;                        fg='red'&#10;                    )&#10;            else:&#10;                self.feedback_status_label.config(text=&quot;❌ Error adding correction&quot;, fg='red')&#10;&#10;            dialog.destroy()&#10;&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Error: {str(e)}&quot;, fg='red')&#10;            dialog.destroy()&#10;&#10;    def update_feedback_buttons(self):&#10;        &quot;&quot;&quot;Update the appearance of feedback buttons based on feedback state&quot;&quot;&quot;&#10;        if self.feedback_given:&#10;            if self.feedback_type == 'positive':&#10;                self.thumbs_up_btn.config(bg='darkgreen', state='disabled', relief='sunken')&#10;                self.thumbs_down_btn.config(bg='lightgray', state='disabled', relief='flat')&#10;            elif self.feedback_type == 'negative':&#10;                self.thumbs_up_btn.config(bg='lightgray', state='disabled', relief='flat')&#10;                self.thumbs_down_btn.config(bg='darkred', state='disabled', relief='sunken')&#10;&#10;            # Enable undo button when feedback is given&#10;            if self.undo_available:&#10;                self.undo_btn.config(state='normal', bg='lightyellow')&#10;        else:&#10;            # Reset to normal state&#10;            self.thumbs_up_btn.config(bg='lightgreen', state='normal', relief='raised')&#10;            self.thumbs_down_btn.config(bg='lightcoral', state='normal', relief='raised')&#10;            self.undo_btn.config(state='disabled', bg='lightgray')&#10;&#10;    def show_feedback_buttons(self):&#10;        &quot;&quot;&quot;Show the feedback dropdown button and reset feedback state&quot;&quot;&quot;&#10;        self.reset_feedback_state()&#10;        # Reset dropdown state&#10;        self.feedback_dropdown_open = False&#10;        self.dropdown_btn.config(text=&quot;▼ Feedback Options&quot;)&#10;        # Make sure the dropdown content is hidden initially&#10;        self.feedback_frame.pack_forget()&#10;        # Show the feedback container (which contains the dropdown button)&#10;        self.feedback_container.pack(pady=10)&#10;&#10;    def hide_feedback_buttons(self):&#10;        &quot;&quot;&quot;Hide the entire feedback section&quot;&quot;&quot;&#10;        # Hide the entire feedback container&#10;        self.feedback_container.pack_forget()&#10;        # Also hide the dropdown content if it was open&#10;        self.feedback_frame.pack_forget()&#10;        # Reset dropdown state&#10;        self.feedback_dropdown_open = False&#10;        self.reset_feedback_state()&#10;&#10;    def toggle_feedback_dropdown(self):&#10;        &quot;&quot;&quot;Toggle the feedback dropdown menu&quot;&quot;&quot;&#10;        if self.feedback_dropdown_open:&#10;            # Close the dropdown&#10;            self.feedback_frame.pack_forget()&#10;            self.feedback_dropdown_open = False&#10;            self.dropdown_btn.config(text=&quot;▼ Feedback Options&quot;)&#10;        else:&#10;            # Open the dropdown&#10;            self.feedback_frame.pack(pady=10)&#10;            self.feedback_dropdown_open = True&#10;            self.dropdown_btn.config(text=&quot;▲ Feedback Options&quot;)&#10;&#10;    def undo_feedback(self):&#10;        &quot;&quot;&quot;Undo the last feedback action&quot;&quot;&quot;&#10;        try:&#10;            if not self.undo_available or not self.last_action_data:&#10;                self.feedback_status_label.config(text=&quot;❌ No action to undo.&quot;, fg='red')&#10;                return&#10;&#10;            action_data = self.last_action_data&#10;            action_type = action_data.get('action_type')&#10;            digit = action_data.get('digit')&#10;&#10;            if action_type == 'positive_feedback':&#10;                # Remove the pattern that was added for positive feedback&#10;                success = self.recognizer.remove_last_pattern(digit)&#10;                if success:&#10;                    self.feedback_status_label.config(&#10;                        text=f&quot;↶ Undone! Removed pattern for digit {digit}&quot;,&#10;                        fg='blue'&#10;                    )&#10;                else:&#10;                    self.feedback_status_label.config(&#10;                        text=&quot;❌ Error: Pattern not found to undo&quot;,&#10;                        fg='red'&#10;                    )&#10;&#10;            elif action_type == 'negative_feedback':&#10;                # Remove the pattern that was added for the corrected digit&#10;                success = self.recognizer.remove_last_pattern(digit)&#10;                if success:&#10;                    corrected_from = action_data.get('corrected_from', 'unknown')&#10;                    self.feedback_status_label.config(&#10;                        text=f&quot;↶ Undone! Removed correction from {corrected_from} to {digit}&quot;,&#10;                        fg='blue'&#10;                    )&#10;                else:&#10;                    self.feedback_status_label.config(&#10;                        text=&quot;❌ Error: Correction not found to undo&quot;,&#10;                        fg='red'&#10;                    )&#10;&#10;            # Reset feedback state&#10;            self.feedback_given = False&#10;            self.feedback_type = None&#10;            self.undo_available = False&#10;            self.last_action_data = None&#10;&#10;            # Update button appearances&#10;            self.update_feedback_buttons()&#10;&#10;            # Save the changes to file&#10;            if not self.recognizer.save_learned_patterns():&#10;                self.feedback_status_label.config(&#10;                    text=&quot;❌ Error saving after undo&quot;,&#10;                    fg='red'&#10;                )&#10;&#10;        except Exception as e:&#10;            self.feedback_status_label.config(text=f&quot;❌ Undo error: {str(e)}&quot;, fg='red')&#10;            print(f&quot;Undo error: {e}&quot;)&#10;&#10;&#10;def main():&#10;    &quot;&quot;&quot;Main function to run the application&quot;&quot;&quot;&#10;    root = tk.Tk()&#10;    app = DigitRecognitionGUI(root)&#10;&#10;    # Handle window closing gracefully&#10;    def on_closing():&#10;        try:&#10;            app.recognizer.save_learned_patterns()&#10;        except Exception as e:&#10;            print(f&quot;Error saving on exit: {e}&quot;)&#10;        root.destroy()&#10;&#10;    root.protocol(&quot;WM_DELETE_WINDOW&quot;, on_closing)&#10;    root.mainloop()&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/simple_recognizer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/simple_recognizer.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Simple and Reliable Digit Recognition&#10;Based on minimal working examples from successful projects&#10;&quot;&quot;&quot;&#10;&#10;import tkinter as tk&#10;from tkinter import ttk&#10;import torch&#10;import torch.nn as nn&#10;import torch.nn.functional as F&#10;import torch.optim as optim&#10;from PIL import Image, ImageDraw&#10;import numpy as np&#10;import cv2&#10;import os&#10;&#10;&#10;class SimpleNet(nn.Module):&#10;    &quot;&quot;&quot;Simple but effective network architecture&quot;&quot;&quot;&#10;    def __init__(self):&#10;        super(SimpleNet, self).__init__()&#10;        self.conv1 = nn.Conv2d(1, 32, 3, padding=1)&#10;        self.conv2 = nn.Conv2d(32, 64, 3, padding=1)&#10;        self.pool = nn.MaxPool2d(2)&#10;        self.fc1 = nn.Linear(64 * 7 * 7, 128)&#10;        self.fc2 = nn.Linear(128, 10)&#10;        self.dropout = nn.Dropout(0.5)&#10;        &#10;    def forward(self, x):&#10;        x = self.pool(F.relu(self.conv1(x)))&#10;        x = self.pool(F.relu(self.conv2(x)))&#10;        x = x.view(-1, 64 * 7 * 7)&#10;        x = F.relu(self.fc1(x))&#10;        x = self.dropout(x)&#10;        x = self.fc2(x)&#10;        return x&#10;&#10;&#10;def create_training_data():&#10;    &quot;&quot;&quot;Create simple, clean digit patterns&quot;&quot;&quot;&#10;    data = []&#10;    labels = []&#10;    &#10;    # Very simple digit templates that actually work&#10;    templates = {&#10;        0: np.array([&#10;            [0,0,1,1,1,0,0],&#10;            [0,1,0,0,0,1,0],&#10;            [1,0,0,0,0,0,1],&#10;            [1,0,0,0,0,0,1],&#10;            [1,0,0,0,0,0,1],&#10;            [0,1,0,0,0,1,0],&#10;            [0,0,1,1,1,0,0]&#10;        ]),&#10;        1: np.array([&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,1,1,0,0,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,1,1,1,1,1,0]&#10;        ]),&#10;        2: np.array([&#10;            [0,1,1,1,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,0,0,0,1,0,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,1,0,0,0,0],&#10;            [0,1,0,0,0,0,0],&#10;            [1,1,1,1,1,1,0]&#10;        ]),&#10;        3: np.array([&#10;            [0,1,1,1,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,0,0,0,1,0,0],&#10;            [0,0,1,1,1,0,0],&#10;            [0,0,0,0,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,1,1,1,1,0,0]&#10;        ]),&#10;        4: np.array([&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,1,1,0,0,0],&#10;            [0,1,0,1,0,0,0],&#10;            [1,0,0,1,0,0,0],&#10;            [1,1,1,1,1,1,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,0,1,0,0,0]&#10;        ]),&#10;        5: np.array([&#10;            [1,1,1,1,1,1,0],&#10;            [1,0,0,0,0,0,0],&#10;            [1,0,0,0,0,0,0],&#10;            [1,1,1,1,1,0,0],&#10;            [0,0,0,0,0,1,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,1,1,1,1,0,0]&#10;        ]),&#10;        6: np.array([&#10;            [0,0,1,1,1,0,0],&#10;            [0,1,0,0,0,0,0],&#10;            [1,0,0,0,0,0,0],&#10;            [1,1,1,1,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,1,1,1,1,0,0]&#10;        ]),&#10;        7: np.array([&#10;            [1,1,1,1,1,1,0],&#10;            [0,0,0,0,0,1,0],&#10;            [0,0,0,0,1,0,0],&#10;            [0,0,0,1,0,0,0],&#10;            [0,0,1,0,0,0,0],&#10;            [0,1,0,0,0,0,0],&#10;            [1,0,0,0,0,0,0]&#10;        ]),&#10;        8: np.array([&#10;            [0,1,1,1,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,1,1,1,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,1,1,1,1,0,0]&#10;        ]),&#10;        9: np.array([&#10;            [0,1,1,1,1,0,0],&#10;            [1,0,0,0,0,1,0],&#10;            [1,0,0,0,0,1,0],&#10;            [0,1,1,1,1,1,0],&#10;            [0,0,0,0,0,1,0],&#10;            [0,0,0,0,1,0,0],&#10;            [0,1,1,1,0,0,0]&#10;        ])&#10;    }&#10;    &#10;    # Generate training samples&#10;    for digit in range(10):&#10;        template = templates[digit]&#10;        for _ in range(200):  # 200 samples per digit&#10;            # Create 28x28 image&#10;            img = np.zeros((28, 28))&#10;            &#10;            # Place template in center with slight variations&#10;            start_y = 10 + np.random.randint(-2, 3)&#10;            start_x = 10 + np.random.randint(-2, 3)&#10;            &#10;            h, w = template.shape&#10;            for i in range(h):&#10;                for j in range(w):&#10;                    if template[i, j] == 1:&#10;                        # Make it thicker and add noise&#10;                        for di in range(2):&#10;                            for dj in range(2):&#10;                                y, x = start_y + i * 2 + di, start_x + j * 2 + dj&#10;                                if 0 &lt;= y &lt; 28 and 0 &lt;= x &lt; 28:&#10;                                    img[y, x] = np.random.uniform(0.8, 1.0)&#10;            &#10;            # Add slight gaussian blur&#10;            img = cv2.GaussianBlur(img, (3, 3), 0)&#10;            &#10;            data.append(img)&#10;            labels.append(digit)&#10;    &#10;    return np.array(data), np.array(labels)&#10;&#10;&#10;def train_model():&#10;    &quot;&quot;&quot;Train the model with clean, simple approach&quot;&quot;&quot;&#10;    print(&quot;Creating training data...&quot;)&#10;    X, y = create_training_data()&#10;    &#10;    # Convert to tensors&#10;    X = torch.FloatTensor(X).unsqueeze(1)  # Add channel dimension&#10;    y = torch.LongTensor(y)&#10;    &#10;    # Create model&#10;    model = SimpleNet()&#10;    criterion = nn.CrossEntropyLoss()&#10;    optimizer = optim.Adam(model.parameters(), lr=0.001)&#10;    &#10;    print(&quot;Training model...&quot;)&#10;    model.train()&#10;    &#10;    # Simple training loop&#10;    for epoch in range(100):&#10;        optimizer.zero_grad()&#10;        outputs = model(X)&#10;        loss = criterion(outputs, y)&#10;        loss.backward()&#10;        optimizer.step()&#10;        &#10;        if epoch % 20 == 0:&#10;            with torch.no_grad():&#10;                _, predicted = torch.max(outputs, 1)&#10;                accuracy = (predicted == y).float().mean()&#10;                print(f'Epoch {epoch}: Loss: {loss.item():.4f}, Accuracy: {accuracy:.4f}')&#10;    &#10;    # Save model&#10;    torch.save(model.state_dict(), 'simple_model.pth')&#10;    print(&quot;Model saved!&quot;)&#10;    return model&#10;&#10;&#10;def preprocess_image(pil_image):&#10;    &quot;&quot;&quot;Simple, reliable preprocessing&quot;&quot;&quot;&#10;    # Convert to grayscale&#10;    img = np.array(pil_image.convert('L'))&#10;    &#10;    # Invert if background is white&#10;    if np.mean(img) &gt; 127:&#10;        img = 255 - img&#10;    &#10;    # Find the bounding box&#10;    coords = np.where(img &gt; 50)&#10;    if len(coords[0]) == 0:&#10;        return None&#10;    &#10;    y_min, y_max = coords[0].min(), coords[0].max()&#10;    x_min, x_max = coords[1].min(), coords[1].max()&#10;    &#10;    # Add padding&#10;    padding = 20&#10;    y_min = max(0, y_min - padding)&#10;    y_max = min(img.shape[0], y_max + padding)&#10;    x_min = max(0, x_min - padding)&#10;    x_max = min(img.shape[1], x_max + padding)&#10;    &#10;    # Crop&#10;    cropped = img[y_min:y_max, x_min:x_max]&#10;    &#10;    # Make square&#10;    h, w = cropped.shape&#10;    size = max(h, w)&#10;    square = np.zeros((size, size))&#10;    &#10;    y_offset = (size - h) // 2&#10;    x_offset = (size - w) // 2&#10;    square[y_offset:y_offset + h, x_offset:x_offset + w] = cropped&#10;    &#10;    # Resize to 28x28&#10;    resized = cv2.resize(square, (28, 28))&#10;    &#10;    # Normalize&#10;    normalized = resized / 255.0&#10;    &#10;    # Apply slight blur to match training&#10;    final = cv2.GaussianBlur(normalized, (3, 3), 0)&#10;    &#10;    return final&#10;&#10;&#10;class DigitApp:&#10;    def __init__(self, root):&#10;        self.root = root&#10;        self.root.title(&quot;Simple Digit Recognizer&quot;)&#10;        self.root.geometry(&quot;600x500&quot;)&#10;        &#10;        # Load or create model&#10;        self.model = SimpleNet()&#10;        if os.path.exists('simple_model.pth'):&#10;            self.model.load_state_dict(torch.load('simple_model.pth', map_location='cpu'))&#10;            print(&quot;Model loaded&quot;)&#10;        else:&#10;            print(&quot;Training new model...&quot;)&#10;            self.model = train_model()&#10;        &#10;        self.model.eval()&#10;        &#10;        self.setup_ui()&#10;        &#10;    def setup_ui(self):&#10;        # Title&#10;        title = tk.Label(self.root, text=&quot;Digit Recognizer&quot;, &#10;                        font=('Arial', 20, 'bold'))&#10;        title.pack(pady=10)&#10;        &#10;        # Canvas&#10;        self.canvas = tk.Canvas(self.root, width=300, height=300, &#10;                               bg='white', relief='solid', bd=2)&#10;        self.canvas.pack(pady=10)&#10;        &#10;        # Bind events&#10;        self.canvas.bind('&lt;Button-1&gt;', self.start_draw)&#10;        self.canvas.bind('&lt;B1-Motion&gt;', self.draw)&#10;        self.canvas.bind('&lt;ButtonRelease-1&gt;', self.end_draw)&#10;        &#10;        # Result&#10;        self.result_label = tk.Label(self.root, text=&quot;Draw a digit&quot;, &#10;                                   font=('Arial', 36, 'bold'), fg='blue')&#10;        self.result_label.pack(pady=10)&#10;        &#10;        self.confidence_label = tk.Label(self.root, text=&quot;&quot;, &#10;                                       font=('Arial', 12))&#10;        self.confidence_label.pack(pady=5)&#10;        &#10;        # Buttons&#10;        button_frame = tk.Frame(self.root)&#10;        button_frame.pack(pady=10)&#10;        &#10;        tk.Button(button_frame, text=&quot;Clear&quot;, command=self.clear, &#10;                 font=('Arial', 12), width=10).pack(side='left', padx=5)&#10;        tk.Button(button_frame, text=&quot;Predict&quot;, command=self.predict, &#10;                 font=('Arial', 12), width=10).pack(side='left', padx=5)&#10;        &#10;        # PIL image for processing&#10;        self.image = Image.new('RGB', (300, 300), 'white')&#10;        self.draw_obj = ImageDraw.Draw(self.image)&#10;        &#10;    def start_draw(self, event):&#10;        self.last_x = event.x&#10;        self.last_y = event.y&#10;        &#10;    def draw(self, event):&#10;        # Draw on canvas&#10;        self.canvas.create_line(self.last_x, self.last_y, event.x, event.y,&#10;                               width=12, fill='black', capstyle='round')&#10;        &#10;        # Draw on PIL image&#10;        self.draw_obj.line([self.last_x, self.last_y, event.x, event.y],&#10;                          fill='black', width=12)&#10;        &#10;        self.last_x = event.x&#10;        self.last_y = event.y&#10;        &#10;    def end_draw(self, event):&#10;        # Auto predict after drawing&#10;        self.root.after(200, self.predict)&#10;        &#10;    def clear(self):&#10;        self.canvas.delete(&quot;all&quot;)&#10;        self.image = Image.new('RGB', (300, 300), 'white')&#10;        self.draw_obj = ImageDraw.Draw(self.image)&#10;        self.result_label.config(text=&quot;Draw a digit&quot;)&#10;        self.confidence_label.config(text=&quot;&quot;)&#10;        &#10;    def predict(self):&#10;        if not self.canvas.find_all():&#10;            return&#10;            &#10;        # Preprocess&#10;        processed = preprocess_image(self.image)&#10;        if processed is None:&#10;            return&#10;            &#10;        # Predict&#10;        input_tensor = torch.FloatTensor(processed).unsqueeze(0).unsqueeze(0)&#10;        &#10;        with torch.no_grad():&#10;            outputs = self.model(input_tensor)&#10;            probabilities = F.softmax(outputs, dim=1)[0]&#10;            &#10;            predicted = torch.argmax(outputs, dim=1).item()&#10;            confidence = probabilities[predicted].item() * 100&#10;            &#10;            # Update display&#10;            self.result_label.config(text=str(predicted))&#10;            self.confidence_label.config(text=f&quot;Confidence: {confidence:.1f}%&quot;)&#10;            &#10;            # Color code&#10;            if confidence &gt; 70:&#10;                self.result_label.config(fg='green')&#10;            elif confidence &gt; 50:&#10;                self.result_label.config(fg='orange')&#10;            else:&#10;                self.result_label.config(fg='red')&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    root = tk.Tk()&#10;    app = DigitApp(root)&#10;    root.mainloop()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>